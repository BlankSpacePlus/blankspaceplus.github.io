---
title: 软件日志
date: 2023-02-10 20:56:11
summary: 本文分享软件日志的相关内容。
tags:
- 软件工程
categories:
- 软件工程
---

# 日志

日志是记录不可变的、只能追加的随时间发生的独立事件的程序。这些事件包括初始化应用程序的时机、磁盘读取失败的时机、用户注销程序的时机等。

一般来说，日志有三种形式：
- 普通文本日志
- 结构化文本日志：此类日志按照某种特定的结构定义，例如JSON、XML。
- 二进制文本日志：此类日志通常提供给应用程序使用，不考虑人的可读性，例如binlog。

当开发者需要更多的上下文信息，以及其他报警或指标无法做到的事情时，日志会非常重要。大量的日志信息难以查阅，因此可以为日志添加一些元数据，例如某一条日志的级别和场景。具体的日志级别由日志框架指定，例如`TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`。

日志的应用实践经验：
- 不要再采用e.printStackTrace()，应该把异常记录到日志中。日志记录异常时，要输出全部异常信息，即e.getMessage()。
- 不要将所有的细节都记录到日志中。日志记录过细会降低性能，引入过多噪声，增加追踪问题的难度和维护的难度。
    - 禁止生产环境开启DEBUG和TRACE级别日志记录。
    - 不要记录冗余的日志信息。
    - 不要既记录异常又抛出异常，否则会记录两次日志。
- 重要的细节信息一定要记录下来。重要的细节主要是整个应用程序的核心处理流程(功能模块)或分支，这对程序调试非常有利。对于需要关注的部分，其入参和出参都要记录下来，选择结构的每个分支都要记录下来。
- 日志信息应该是有意义的。日志信息一定要包含上下文信息，还要能被程序解析，这对日后诊断问题非常有帮助。
- 日志文件应该按级别和时间分离，方便查阅。
- 对于`TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`日志级别，INFO用于一般信息，DEBUG、TRACE用于更细粒度的诊断信息，WARN、ERROR用于需要人员跟进的异常事件。
    - TRACE：最详细的记录，只写入日志文件。
    - DEBUG：记录关键逻辑里的运行时数据。
    - INFO：记录排查问题的关键信息。
    - WARN：对业务影响不大的一般性错误，开发应该关注。
    - ERROR：比较严重的错误，需要运维配置监控。
- Logger属性推荐采用单例模式，避免反复创建。推荐阅读：[单例模式](https://blankspace.blog.csdn.net/article/details/105337542)
- 结构化文本日志可以采用JSON格式，方便日志被解析到一个外部的、集中式的日志聚合平台(例如ELK)。推荐阅读：[JSON必知必会](https://blankspace.blog.csdn.net/article/details/102060462)
- 日志文件应该定期循环，避免日志文件过大或日志数据丢失。日志最好以异步方式(为了提升系统性能)传输到集中式日志存储中，且做好容错、高可用、灾备。推荐阅读：[容错、高可用、灾备](https://blankspace.blog.csdn.net/article/details/104633041)
- 定期检查所有日志，意外出现的WARN、ERROR、异常信息等格外关注。
- 记录日志时也要关注String拼接带来的性能损耗，推荐使用占位符`{}`而不是字符串拼接`+`以提升性能。
- 日志中不应该记录敏感信息，这对系统安全合规非常重要。
- 云上日志不完全可靠，必须本地配置日志，定时将云上日志发送至本地的日志聚合平台。

推荐阅读：[The 10 commandments of logging](https://www.masterzen.fr/2013/01/13/the-10-commandments-of-logging/)

Java日志框架分为日志实现框架和日志门面框架。
- 日志实现框架：
    - JDK Logging (JUL)
    - Log4j (Deprecated) / Log4j2
    - Logback
- 日志Facade框架：
    - Apache Commons Logging (JCL)
    - Slf4j

# JUL

JDK自带的日志系统简称JUL，位于`java.util.logging.*`包下。

JUL的日志级别分为：`ALL`、`FINER`、`FINE`、`INFO`、`WARNING`、`SEVERE`、`OFF`。Java9对传统的JUL日志进行了改进，改为`ALL`、`TRACE`、`DEBUG`、`INFO`、`WARNING`、`ERROR`、`OFF`。

JUL只定义了记录消息的最小日志API，没有提供异步、缓存等优化手段，因此不推荐采用。实际开发中，普遍采用第三方的优质日志框架。不推荐log4j-logback，推荐Slf4j。

JUL的用法非常简单：
```java
System.Logger logger = System.getLogger("test");
Logger.getLogger("test").setLevel(Level.INFO);
```

# Log4j

Log4j引入AsyncAppender做异步日志，其日志级别分为：`DEBUG`、`INFO`、`WARN`、`ERROR`、`FATAL`。

依赖引入：
```xml
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>${log4j.version}</version>
</dependency>
```

配置文件：
```yaml
### 设置###
log4j.rootLogger = debug,stdout,D,E

### 输出信息到控制抬 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n

### 输出DEBUG 级别以上的日志到Log4jTestDebug.log ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = Log4jTestDebug.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n

### 输出ERROR 级别以上的日志到Log4jTestError.log ###
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
log4j.appender.E.File =Log4jTestError.log
log4j.appender.E.Append = true
log4j.appender.E.Threshold = ERROR
log4j.appender.E.layout = org.apache.log4j.PatternLayout
log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
```

测试代码：
```java
import org.apache.log4j.Logger;

public class Log4jTest {

    private static final Logger logger = Logger.getLogger(Log4jTest.class);

    public static void main(String[] args) {
        // 记录DEBUG级别的信息
        if (Logger.getRootLogger().isDebugEnabled()) {
            logger.debug("This is debug message.");
        }
        // 记录INFO级别的信息
        if (Logger.getRootLogger().isInfoEnabled()) {
            logger.info("This is info message.");
        }
        // 记录ERROR级别的信息
        logger.error("This is error message.");
    }

}
```

# Log4j2

2020年08月05日Apache宣布Apache1.x寿终正寝，建议升级2.x。Log4j2是Log4j1.x的升级版，提供了部分Logback的优点，修复了Logback架构的固有问题。Log4j2将API与实现分离，开发人员可以更清楚地了解可以使用哪些类和方法，同时保障了向前兼容性。

Log4j2将API与实现分离，主要包含两部分：
- `log4j-api`：作为日志接口层，用于统一底层日志系统。
- `log4j-core`：作为上述日志接口的实现，是一个实际的日志框架。

Log4j2的配置方式不含`Properties`，只含`XML`、`JSON`、`YAML`，配置文件加载顺序：
- log4j2-test.json/log4j2-test.jsn
- log4j2-test.xml
- log4j2.json/log4j2.jsn
- log4j2.xml

Log4j2日志级别分为：`TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`、`FATAL`，还允许自定义日志类别。

Log4j2提供了占位符功能：`logger.debug("error:{}", e.getMessage());`

Log4j2引入基于LMAX的Disruptor的无锁异步日志来进一步提升异步日志的功能。

依赖引入：
```xml
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>${log4j2.version}</version>
</dependency>
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>${log4j2.version}</version>
</dependency>
```

配置文件：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration status="error">
    <!--先定义所有的appender -->
    <appenders>
        <!--这个输出控制台的配置 -->
        <Console name="Console" target="SYSTEM_OUT">
            <!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） -->
            <ThresholdFilter level="trace" onMatch="ACCEPT" onMismatch="DENY"/>
            <!--这个都知道是输出日志的格式 -->
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </Console>
        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用 -->
        <!--append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true -->
        <File name="log" fileName="log4j2.log" append="false">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </File>
        <!--添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别  onMatch="ACCEPT" onMismatch="DENY"意思是匹配就接受,否则直接拒绝  -->
        <File name="ERROR" fileName="error.log">
            <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="%d{yyyy.MM.dd 'at' HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </File>
        <!--这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 -->
        <RollingFile name="RollingFile" fileName="web.log"
                     filePattern="logs/$${date:yyyy-MM}/web-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n"/>
            <SizeBasedTriggeringPolicy size="2MB"/>
        </RollingFile>
    </appenders>
    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 -->
    <loggers>
        <root level="trace">
            <appender-ref ref="RollingFile"/>
            <appender-ref ref="Console"/>
            <appender-ref ref="ERROR" />
            <appender-ref ref="log"/>
        </root>
    </loggers>
</configuration>
```

测试代码：
```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Log4j2Test {

    private static final Logger logger = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);

    public static void main(String[] args) {
        // 记录trace级别的信息
        logger.trace("log4j2日志输出：This is trace message.");
        // 记录debug级别的信息
        logger.debug("log4j2日志输出：This is debug message.");
        // 记录info级别的信息
        logger.info("log4j2日志输出：This is info message.");
        // 记录error级别的信息
        logger.error("log4j2日志输出：This is error message.");
    }

}
```

# Logback

推荐阅读：[Logback官方文档手册](http://logback.qos.ch/manual/)

Logback日志级别分为：`TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`。

Logback主要包含三个模块：
- `logback-core`：基础模块。
- `logback-classic`：Log4j的一个改良版本，完整实现Slf4j的API，便于切换其他日志系统。
- `logback-access`：访问模块与Servlet容器集成通过HTTP来访问日志的功能。

Logback配置文件默认从classpath路径下读取，配置文件加载顺序如下：
- logback.groovy
- logback-test.xml
- logback.xml

依赖引入：
```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>${slf4j-api.version}</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-core</artifactId>
    <version>${logback-core.version}</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-access</artifactId>
    <version>${logback-access.version}</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>${logback-classic.version}</version>
</dependency>
```

配置文件：
```xml
<!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL -->
<!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 -->
<!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 -->
<!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 -->
<!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->
<!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->
<configuration scan="true" scanPeriod="60 seconds" debug="false">
    <!-- 动态日志级别 -->
    <jmxConfigurator />
    <!-- 定义日志文件 输出位置 -->
    <property name="log_dir" value="log" />
    <!-- 日志最大的历史 30天 -->
    <property name="maxHistory" value="30" />
    <!-- ConsoleAppender 控制台输出日志 -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                <!-- 设置日志输出格式 -->
                %d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger - %msg%n
            </pattern>
        </encoder>
    </appender>
    <!-- ERROR级别日志 -->
    <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender -->
    <appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 过滤器，只记录WARN级别的日志 -->
        <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 设置过滤级别 -->
            <level>ERROR</level>
            <!-- 用于配置符合过滤条件的操作 -->
            <onMatch>ACCEPT</onMatch>
            <!-- 用于配置不符合过滤条件的操作 -->
            <onMismatch>DENY</onMismatch>
        </filter>
        <!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志输出位置 可相对、和绝对路径 -->
            <fileNamePattern>
                ${log_dir}/error/%d{yyyy-MM-dd}/error-log.log
            </fileNamePattern>
            <!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且<maxHistory>是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除 -->
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>
                <!-- 设置日志输出格式 -->
                %d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger - %msg%n
            </pattern>
        </encoder>
    </appender>
    <!-- WARN级别日志 appender -->
    <appender name="WARN" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 过滤器，只记录WARN级别的日志 -->
        <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 设置过滤级别 -->
            <level>WARN</level>
            <!-- 用于配置符合过滤条件的操作 -->
            <onMatch>ACCEPT</onMatch>
            <!-- 用于配置不符合过滤条件的操作 -->
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志输出位置 可相对、和绝对路径 -->
            <fileNamePattern>${log_dir}/warn/%d{yyyy-MM-dd}/warn-log.log</fileNamePattern>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>
    <!-- INFO级别日志 appender -->
    <appender name="INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log_dir}/info/%d{yyyy-MM-dd}/info-log.log</fileNamePattern>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>
    <!-- DEBUG级别日志 appender -->
    <appender name="DEBUG" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>DEBUG</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log_dir}/debug/%d{yyyy-MM-dd}/debug-log.log</fileNamePattern>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>
    <!-- TRACE级别日志 appender -->
    <appender name="TRACE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>TRACE</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log_dir}/trace/%d{yyyy-MM-dd}/trace-log.log</fileNamePattern>
            <maxHistory>${maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>
    <!-- root级别 DEBUG -->
    <root>
        <!-- 打印debug级别日志及以上级别日志 -->
        <level value="debug" />
        <!-- 控制台输出 -->
        <appender-ref ref="console" />
        <!-- 文件输出 -->
        <appender-ref ref="ERROR" />
        <appender-ref ref="INFO" />
        <appender-ref ref="WARN" />
        <appender-ref ref="DEBUG" />
        <appender-ref ref="TRACE" />
    </root>
</configuration>
```

测试代码：
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.core.util.StatusPrinter;

public class LogbackTest {

    private static final Logger logger = LoggerFactory.getLogger(LogbackTest.class);

    public static void main(String[] args) {
        // 记录TRACE级别的信息
        logger.trace("This is trace message.");
        // 记录DEBUG级别的信息
        logger.debug("This is debug message.");
        // 记录INFO级别的信息
        logger.info("This is info message.");
        // 记录WARN级别的信息
        logger.warn("This is warn message.");
        // 记录ERROR级别的信息
        logger.error("This is error message.");
        // print internal state
        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
        StatusPrinter.print(loggerContext);
    }

}
```

# JCL

JCL是Apache Commons Logging的缩写，其日志级别分为：`TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`、`FATAL`。

引入依赖：
```xml
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>${commons-logging.version}</version>
</dependency>
```

测试代码：
```java
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class JclTest {

    private static final Log logger = LogFactory.getLog(JclTest.class);

    public static void main(String[] args) {
        // 记录TRACE级别的信息
        if (logger.isTraceEnabled()) {
            logger.trace("This is trace message.");
        }
        // 记录DEBUG级别的信息
        if (logger.isDebugEnabled()) {
            logger.debug("This is debug message.");
        }
        // 记录INFO级别的信息
        if (logger.isInfoEnabled()) {
            logger.info("This is info message.");
        }
        // 记录WARN级别的信息
        if (logger.isWarnEnabled()) {
            logger.warn("This is warn message.");
        }
        // 记录ERROR级别的信息
        if (logger.isErrorEnabled()) {
            logger.error("This is error message.");
        }
        // 记录FATAL级别的信息
        if (logger.isFatalEnabled()) {
            logger.fatal("This is fatal message.");
        }
    }

}
```

# Slf4j

Slf4j只提供接口，无任何实现，底层默认采用Logback。

引入JUL作为日志实现：
```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jul-to-slf4j</artifactId>
    <version>${jul-to-slf4j.version}</version>
</dependency>
```

引入Log4j作为日志实现：
```xml
<dependencies>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>${log4j.version}</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>${slf4j-log4j12.version}</version>
    </dependency>
</dependencies>
```

引入Log4j2作为日志实现：
```xml
<dependencies>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>${log4j.version}</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-api</artifactId>
        <version>${log4j.version}</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-slf4j-impl</artifactId>
        <version>${log4j-slf4j-impl.version}</version>
    </dependency>
</dependencies>
```

测试代码：
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Slf4jTest {

    private static final Logger logger = LoggerFactory.getLogger(Slf4jTest.class);

    public static void main(String[] args) {
        // 记录trace级别的信息
        logger.trace("This is trace message.");
        // 记录debug级别的信息
        logger.debug("This is debug message.");
        // 记录info级别的信息
        logger.info("This is info message.");
        // 记录error级别的信息
        logger.error("This is error message.");
        // 记录warn级别的信息
        logger.warn("This is warn message.");
    }

}
```
