---
title: 设计原则与设计模式
date: 2022-03-14 01:44:55
summary: 本文分享设计原则与设计模式。
tags:
- 设计模式
- 软件工程
categories:
- 软件工程
---

# 设计原则

面向对象的设计原则通常指<font color="red">SOLID</font>原则：

| 首字母 | 英文缩写 | 英文名称 | 中文名称 | 说明 | 应用场景 |
|:----:|:----:|:----:|:----:|:----:|:----:|
| S | SRP | Single Reponsibility | 单一职责原则 | 对象应该只具备单一职责 | 用于类的设计 |
| O | OCP | Open/Close Principle | 开闭原则 | 软件体应该对于扩展开放，但是对于修改关闭 | 作为总指导思想 |
| L | LSP | Liskov Substitution Principle | 里氏替换原则 | 程序中的对象应该是可以在不变程序正确性的前提下被它的子类所替换 | 用于指导类继承的设计 |
| I | ISP | Interface Segregation Principle | 接口隔离原则 | 多个特定客户端接口要好于一个具有宽泛用途的接口 | 用于指导接口的设计 |
| D | DIP | Dependency Inversion Principle | 依赖反转原则 | 依赖于抽象而不是依赖于一个实例 | 用于指导如何抽象 |

设计原则是一种判断标准，并非非此不可。

Arthur J.Riel在《OOD启示录》一书中写道：
> 你不必严格遵守这些规则，违背它们也不会被处以宗教刑罚。但你应该把这些原则看作警铃，若违背了其中一条，那么警铃就会响起。

不要过度设计。
过分设计会导致设计方案出现不必要的复杂，代码量庞大，投入产出不成正比，项目计划难以按时完成。
所谓“过犹不及”，过度设计带来的危害可能比设计不足的危害更大。

## SRP

一个类应该有且只有一个职责。

一个类的职责是引起该类变化的原因，如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，其实就是耦合了多个互不相关的职责，就会降低这个类的内聚性。

类的职责是站在其他类的角度来定义的，包含多个相关功能。

一个类有多个方法，这些方法是相关的。

只适用于那些基础类，而不适用于基于基础类构建复杂的聚合类。

## OCP

对扩展开放，对修改关闭，不用修改代码就可以增加新的功能。

对使用者修改关闭，对提供者扩展开放；提供者增加新的功能，但使用者不需要修改代码。

已有函数修改名称、参数、返回值，或者增加新的函数，OCP就不再适用了。

## LSP

子类的对象提供了父类的所有行为，并且加上了子类额外的一些内容（功能或属性）。当程序基于父类实现时，将子类替换父类而程序不需要修改。

函数使用指向父类的指针或引用时，必须能够在不知道子类类型的情况下使用子类的对象。

子类必须能替换成它们的父类。

子类必须实现或者继承父类所有的共有方法，否则调用者调用了一个父类中有，而子类中没有的方法，运行时就会出错。
子类每个方法的输入参数必须和父类一样，否则调用父类的代码不能调用子类。
子类每个方法的输出（返回值、修改全局变量、插入数据库、发送网络数据等）必须不比父类少，否则无法完成基于父类输出的处理。

## ISP

客户端不应该被强迫去理解它们并不需要的接口。

ISP承认对象需要非内聚接口，建议客户端不需要知道整个类，只需要知道具有内聚接口的抽象父类即可。
某些类不满足SRP，但需要使用调用这些类的类应该根据父类来使用它们，不应直接使用它们，这时可用到ISP。

## DIP

高层模块不应该直接依赖低层模块，两者都应该依赖于抽象层。

抽象不能依赖细节，细节必须依赖抽象。

模块有复杂的含义，可能指子系统、模块、组件、类，根据不同的视角而定。

对依赖的理解：
- 高层模块依赖低层模块：高层模块需要调用底层模块的方法。
- 高层模块依赖抽象层：高层模块基于抽象层编程。
- 低层模块依赖抽象层：低层模块继承或实现抽象层。
- 细节依赖抽象：实现抽象层。

# 设计模式

设计模式源于GoF的经典著作《设计模式——可复用面向对象软件的基础》，应用于面向对象领域，解决可复用的设计问题。

应用设计模式切忌一知半解就生搬硬套。

设计模式的精髓在于“对变化的概念进行封装”，拥抱变化，却又不能让变化引入过大的风险。

设计原则和设计模式并非竞争关系，而是互补关系。二者的互补性体现在：设计原则主要用于指导类的定义的设计，而设计模式主要用于指导类的行为的设计。

设计原则是类的静态设计原则，设计模式是类的动态设计原则。

GoF提出的设计模式一共有23种，分为3大类：
- **创建型设计模式**：通过创建对象来解决设计问题
    - **抽象工厂模式**：创建几个类家族的一个实例
    - **建造者模式**：允许相同结构的过程创建不同的实现
    - **工厂方法模式**：创建几个可能的衍生类的一个类型
    - **原型模式**：要被克隆的一个类
    - **单例模式**：限制一个类实例化只能是一个实例
- **结构型设计模式**：通过确定实现实体间关系的简单方式来解决问题
    - **适配器模式**：适配不同类的接口
    - **桥接模式**：从实现中分离出抽象
    - **组合模式**：相似类的合成类
    - **装饰器模式**：允许给类动态地添加额外的特性
    - **门面模式**：提供简化接口的单类
    - **享元模式**：使用共享机制来有效地支持大量细粒度类
    - **代理模式**：起到接口功能的类
- **动作型设计模式**：通过确定对象间通用交互模式来解决设计问题
    - **责任链模式**：通过类链来处理申请的方式
    - **命令模式**：在类中封装一个行为
    - **解释器模式**：应用特定语言元素的方式
    - **迭代器模式**：频繁地访问集合元素
    - **中介者模式**：为一组接口提供统一的接口
    - **备忘录模式**：捕获并存储对象的内部状态
    - **观察者模式**：允许在运行时观察对象的内部状态
    - **状态模式**：允许在运行时部分改变对象的类型
    - **策略模式**：允许在运行时动态选择算法
    - **模板方法模式**：将算法的实现延迟到子类中
    - **访问者模式**：不改变类的情况下给类添加新的操作

设计模式的优点：
- 通过解决通常的设计问题来促进重用，可通过仔细协调那些可进一步加强重用的特性来提高设计模式的可复用性。
- 设计模式提供高层次的设计文档，因为这些模式把设计抽象列为条件。
- 许多设计模式的实现已经存在，在这些情况中，没必要对程序中已实现设计模式的那部分进行编码和写文档。
- 如果维护程序员对设计模式很熟悉，将会更容易领会加入了设计模式的程序。

设计模式的缺点：
- 在软件产品中使用设计模式意味着正在使用的语言不够强大。
- 缺乏系统化的方式确定应该应用设计模式的时机和方法，仍然处于使用自然语言的非正式描述状态，只能依赖人工，不能使用CASE工具。
- 缺乏系统化的方式确定应该多个相互关联的设计模式的使用情况。
- 对已有软件产品改进模式，无论是传统的还是面向对象的，都不太可能。
