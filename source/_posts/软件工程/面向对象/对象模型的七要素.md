---
title: 对象模型的七要素
date: 2021-03-17 21:24:47
summary: 对象模型具有七个要素，其中有四个主要要素和三个次要要素，本文分享这七个要素。
tags:
- 面向对象
- 软件工程
categories:
- 软件工程
---

# 对象模型的主要要素

**所谓“主要”，指的是如果一个模型不具有这些元素之一，就不是面向对象的。**

## 抽象

> 抽象是人类处理复杂性的基本方式。

> 抽象描述了一个对象的基本特征，可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的视角有关。

抽象关注一个对象的外部视图，所以可以用来分离对象的基本行为和它的实现。

对于给定的问题域决定一组正确的抽象，就是面向对象设计的核心问题。

> 从那些准确地为问题域实体建模的对象到那些实际上没有什么理由存在的对象，存在着一系列的抽象：
> - 实体抽象：一个对象，代表了问题域或解决方案域实体的一个有用的模型。
> - 动作抽象：一个对象，提供了一组通用的动作，所有的这些操作都执行同类的功能。
> - 虚拟机抽象：一个对象，集中了某种高层控制所用到的所有操作或者这些操作将利用某种更底层的操作集。
> - 偶然抽象：一个对象，封装了一组互相间没有关系的操作。

抽象思想的核心是不变性的概念。
不变量是某种布尔条件，它的值必须保持不变。
对于对象的每个操作，我们可以定义“前置条件”（操作假定的不变量）和“后置条件”（操作满足的不变量），违反一个不变量将会破坏一个抽象相关的契约。
如果违反了前置条件，则说明客户没有完成属于它的那部分责任，因此服务器不能可靠地执行；如果违反了后置条件，则说明服务器没有完成属于它的那部分责任，因此客户不能再信任服务器的行为。
出现异常表示某个不变量没有满足或者不能满足。某些语言允许抛出异常，这样就可以终止处理并向其他对象报告问题，然后这些对象就可以捕捉异常并解决问题。

所有的抽象都有静态和动态属性。

没有对象是孤立的，每个对象都与其他对象协作，实现某些行为。这些对象如何协作的设计决策，定义了某种抽象的边界，从而也定义了每个对象的责任和协议。

## 封装

对象的抽象应该优先于它的实现被确定。
当选择了一种实现之后，它就应该作为这种抽象后面的秘密，对大多数客户隐藏，因此需要封装。

抽象和封装是互补的概念。
抽象关注的是对象可以观察到的行为，而封装关注的是这种行为的实现。封装通常是通过信息隐藏来实现的，当然，并不只是数据隐藏。信息隐藏是将那些不涉及对象本质特征的秘密都隐藏起来的过程。通常，对象的结构是隐藏的，其实现方法也是隐藏的。

> 复杂系统的每一部分都不应该依赖于其他部分的细节。

> 抽象帮助人们思考他们做什么。
> 封装可以让程序员借助最少的工作进行可靠的修改。

封装在不同的抽象之间提供了明确的边界，因此导致了清晰的分离关注。
一个抽象上的对象应该看不到较低抽象层次上的实现细节。

> 要让抽象能工作起来，就必须将实现封装起来。

每个类必须有两部分：一个接口和一个实现。
- 类的接口描述了它的外部视图，包含了这个类的所有实例的共同行为的抽象。通过类的接口，我们能知道客户可以对这个类的所有实例做哪些假定。
- 类的实现包括抽象的表示以及实现期望行为的机制。实现封装了细节，客户不能对这些细节做任何假定。


> 封装是一个过程，它分隔构成抽象的结构和行为的元素。
> 封装的作用是分离抽象的概念接口及其实现。

明智的封装使可能改变的设计决策局部化。随着系统的演进，开发者可能会发现，在实际使用过程中，某种操作花的时间超过了可接受的范围，某些对象使用的空间超过了可用的空间。此时，对象的表示方法常常会改变，这样就可以采用更高效的算法，或者通过计算而不是存储某些数据来优化空间的使用。抽象让我们既能改变表示方法，同时又不影响其客户，这就是封装的根本好处。

隐藏是一个与封装相关的概念：在一个抽象层次隐藏起来的东西，在另一个抽象层次里可能代表了外部视图。对象的内部表示方法可能被揭示出来，但是绝大多数情况下，只有当这个抽象的创造者显式地暴露出实现，并且客户愿意接受由此而带来的额外的复杂性时，才会这样做。所以，封装并不能阻止开发者做蠢事。

> 隐藏是为了防止事故，而不是防止欺骗。

## 模块化

> 模块化将程序分为一些模块，这些模块可以独立地编译，但又与其他的模块有联系。

> 模块间的联系是模块相互之间所做出的假定。

大多数语言将模块作为一个独立的概念，它们也区分模块的接口和它们的实现。
模块化和封装是密不可分的。

对于一个给定问题确定一组正确的模块，这与决定一组正确的抽象的难度差不多。

模块作为一种物理容器，我们在其中声明逻辑设计中的类和对象。

对很小的问题来说，开发者可能决定将所有的类和对象都声明在同一个包中。
对于稍微有点实际意义的软件来说，更好的解决方案是将逻辑上相关的类和对象放在同一个模块中，只暴露出其他模块必须看到的元素。
一旦模块划分不当，信息隐藏可能造成相反的效果，随意的模块化有时候比不实现模块化还糟糕。

开发者必须平衡好封装抽象的愿望以及让其他模块看到某些抽象的需要。

## 层次结构

一组抽象常常构成一个层次结构，通过在设计中确定这些层次结构，可能会极大地简化对系统的理解。

> 层次结构是抽象的一种分级或排序。

复杂的OO系统中，最重要的两种层次结构是类结构和对象结构。

类的层次结构包含继承、聚合等。

# 对象模型的次要要素

**所谓“主要”，指的是这些要素是对象模型的重要组成部分，但不是本质的。**

## 类型

> 一个类型是关于结构或行为属性的准确描述，一组实体共享这些属性。

> 类型⇔类

> 类型是关于一个对象的类的强制规定，如此，不同类型的对象不能互换使用，或者至少它们的互换使用收到非常严格的限制。

某种编程语言可以是强类型、弱类型甚至无类型的，不影响它们可能是面向对象的。
类型匹配的概念是类型概念的核心。
强类型使得可以利用编程语言来执行某些设计决策，可以保证系统在复杂度不断增长时还能保持特定的关联，但它引入了语义上的依赖关系。

## 并发

并发可分为重量级并发和轻量级并发：
- 重量级并发：重量级进程由目标OS独立管理，具有自己的地址空间。
- 轻量级并发：轻量级进程通常与其他轻量级进程一起处于单个OS的进程之内，共享地址空间。

设计一个大型并发系统必须充分考虑死锁、活锁、饥饿、[竞争条件](https://blankspace.blog.csdn.net/article/details/113484279)等问题。

> 在更高层次的抽象中，通过将并发隐藏在可复用的抽象中，OOP可以减轻大多数程序员在并发问题上的负担。

> 对象模型适合于分布式系统，因为隐式地定义了发布和移动的单元以及实体的通信。

> 并发是一种属性，它区分了主动对象和非主动对象。

在并发的情况下，仅定义对象的方法是不够的，还必须确保这些方法的语义在多个控制线程的情况下仍然有效。

## 持久

> 持久是对象的一种属性，利用这种属性，对象跨越时间和空间而存在。
