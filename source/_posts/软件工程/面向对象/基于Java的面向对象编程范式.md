---
title: 基于Java的面向对象编程范式
date: 2020-09-26 19:25:50
summary: 本文分享学习"基于Java的面向对象编程范式"的学习笔记。
tags:
- 面向对象
- 软件工程
categories:
- 软件工程
---

# 课程信息

学习链接：[中国大学慕课-南京大学-基于Java的面向对象编程范式](https://www.icourse163.org/course/NJU-1002246017)

# 学习笔记

1. 面向对象的世界观里，类有两种职责：数据职责和行为职责，这两种职责并存于类中。
2. 类和对象都是职责的体现，不同的是一个抽象一个具体。
3. 面向对象编程是有职责的对象之间的协作。
4. 不同的视角：结构化方法→行为视角、数据为中心方法→数据视角、面向对象方法→职责视角。
5. 想要解决一个问题，我们会希望在问题空间找到一种建模的方式，然后将问题空间的问题转化为解空间的答案。
6. 对象是一种建模方法，它既表示客观世界的问题空间中某个具体的事物，又表示软件系统解空间的基本元素。
7. 没有行为的类，可以被设计为某个其他类的属性。
8. 类是描述相同事物的集合，它以概要的方式描述了相同事物集合中的所有元素，但却允许类中的每个实体元素可以在非本质特征上变化。
9. 为什么不要重复造轮子？因为轮子的设计已经足够应对变更了（疯狂暗示软件复用）。
10. 代码提交前必须进行单元测试。单元测试针对于软件设计的最小单位方法展开正确性检验。
11. 单元测试有两种情况：独立且与其他方法无关（独立测试即可）；半独立且只与同类中的方法有依赖关系（先测被依赖的方法）。
12. 一种好的类设计方案：
    ```java
    public class Position {
        public double distance(Position position) {
            // calculate and return the distance from this object to position
        }
        public double heading(Position position) {
            // calculate and return the heading from this object to position
        }
        public double latitude;
        public double longitude;
    }
    ```
13. 封装可以将将潜在的变更与外界隔离开来。
14. 封装具有三原则：将数据与操作数据的行为放在一起；用职责驱动的设计原则来决定数据和行为在一起；职责要具有完备性。
15. 关于类设计完备性的说明。
完备性是一个数学上的概念，下面举例说明：
比如我们有一个水杯，它只进水不出水就是不完备的……
特殊情况下，设计可能不能是完备的，比如会计打发票，就算打错了，可以红冲处理掉但不可能把已发生的支付过程取消掉……
16. 静态不能访问非静态。
17. 一个对象的整体协议可能会分为多个内聚的逻辑行为组。划分后的每个逻辑行为组就描述了对象的一个独立职责，体现了对象的一个独立角色。如果一个对象拥有多个行为组，就意味着该对象拥有多个不同的职责，需要扮演多个不同的角色。每个角色都是对象的一个职责的体现，所有的角色是对象所有职责的体现。理想的单一职责对象应该仅仅扮演一个角色。
18. 职责的分配原则：覆盖到所有重要的方面，寻找需要执行的动作以及需要维护和生成的信息。
19. 单一职责的实施：当发现两变化同时要求我们修改这个类时，就要考虑拆分这个类。
20. 一组对象共同协作履行整个应用软件的责任。
21. 系统职责的划分可以是从小到大，将小职责聚合为大职责；也可以是从大到小，将大职责分配给小对象。自底向上和自顶向下往往是同时使用的。
22. 对于一个对象来说，它可以与四种对象协作：它自身、任何以参数形式传入的对象、被该对象直接创建的对象、其所持有的对象引用。总结就是：一个对象可以和能拿到引用的对象协作。
23. 面向对象程序设计的一些关系：
一般关系：依赖
对象层次的关系：连接、关联
类层次的关系：继承、实现
24. 依赖体现了一种物理关系，因为这种依赖关系不仅仅体现在类和类之间，甚至可以存在于其他的软件工程元素之间。
我们可以说，一个类依赖于另一个类，一个对象依赖于另外一个对象，一个用例依赖于另外一个用例，一个包依赖于另外一个包，总之依赖表达了一种物理上的连接。
25. 连接表达了对象与对象之间的一种连接，它是一种表达一种联系的具体的实例。
26. 关联体现了对象与对象之间的一种逻辑关系，可分为：普通关联、聚合、组合。
27. 关系的强度：依赖 < 普通关联 < 聚合 < 组合
28. 依赖是一种“...uses a...”关系，就是某个对象的功能依赖于另外的某个对象，而被依赖的对象仅仅作为一种工具在使用，该对象不持有被依赖对象的引用。UML中依赖关系表现为[虚线+鱼骨箭头]。
29. 关联是一种“...has a...”关系，就是某个对象会长期持有另一个对象的引用，而二者的关联往往也是相互的。关联的两个对象彼此之间没有任何强制性的约束，只要是二者同意，可以随时解除关系或进行关联，它们在生命周期上没有任何约定。被关联的对象还可以被别的对象关联，所以被关联对象是可以共享的。关联可以是单向的也可以是双向的，可以是普通关联也可以是可导航关联。
30. 关联的多重性通过一条实线来表达，可接鱼骨箭头表示方向性。
31. 聚合是一种“...owns a...”关系，是一种强版本的关联，它暗含一种所属关系以及生命周期关系。UML中聚合关系中间一条实线，一端是指向所有方的空心菱形，另一端是指向被所有方的鱼骨箭头。被聚合的对象还可以被别的对象关联，所以被聚合对象是可以共享的。
32. 组合是一种“...is a part of...”关系，是一种最强版本的关联，它直接要求包含对象对被包含对象的拥有以及被包含对象生命周期的关系。UML中组合关系中间一条实线，一端是指向所有方的实心菱形，另一端是指向被所有方的鱼骨箭头。被组合的对象还可以被别的对象关联，所以被聚合对象是可以共享的，然而绝不存在两个包含对象对同一个被包含对象的共享。
33. 组合不但把关联到的对象作为一个成员变量，并在此处new了一个对象。这一点是非常重要的。
34. 可修改性有三重含义：狭义可修改性（对已有实现的修改不影响到其他实现）、可扩展性（对新的实现的扩展不影响到已有的其他实现）、灵活性（实现动态配置）。
35. 继承的由来：利用泛化关系实现代码重用和抽象等。备注：泛化≠继承。
36. 可以继承什么、可以覆盖什么：
子类继承了父类所有的成员变量和成员方法。
子类可以增加父类的成员变量和成员方法。
子类可以覆盖父类的成员方法。
子类不可以覆盖父类的成员变量。
37. 继承是一种“...is a...”关系，“A is B, B is C → A is C”。
38. 编译时，编译器根据引用变量的类型（而不是引用变量指向的类型）决定能否调用某个方法；执行时，JVM依据实际引用变量指向对象的类型决定实际哪个方法被调用。这就是所谓“编译时类型”和“运行时类型”的区别，即所谓“编译时类型”是我们的Java代码中定义的变量类型，“运行时类型”看的是这个对象到底是什么类型（被new成了什么），这是学习多态时必须理解的。如此，我们就对`SuperClass obj = new SubClass();`有了更深刻的理解。
39. 多态通过分离“做什么”和“怎么做”，从另一个角度将接口和实现分离开来。多态不仅能够改善代码的组织结构和可读性，还能创建“可扩展”的程序，即无论在项目最初创建时，还是在需要添加新功能时，都可以进行扩充。
40. 多态使得系统更容易理解，其作用之一就是消除类型之间的耦合关系。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要他们都是从同一基类导出来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。
41. 多态的意思是多种形式，多种形式的意思是可以出现不同的计算类型，并且在运行的时候动态的确定正确的计算。
42. 多态是指一个多个方法使用同一个名字却有多种解释，当使用这个名字去调用方法时，系统将选择重载自动的选择其中的一个方法。在多态中只关心一个对象做什么，而不关心如何去做。
43. 子类对象可以赋给父类引用变量，父类对象不可以赋给子类引用对象。
44. Overriding的限制：参数必须一致，返回值必须兼容，方法的可达性不能降低。
45. 非抽象类中不可以有抽象方法，抽象类中可以有非抽象方法。
46. 抽象方法的存在就是为了多态，具体的类必须实现所有的抽象方法，实现抽象方法就像子类覆盖父类的方法一样。
47. 子类继承父类，就会把父类完全继承过来，二者之间存在一种规约，即父类拥有什么接口，子类也具有什么接口。父类变子类也要变；而组合的两端没有“契约”的存在，有时会显得更好。
48. 组合和继承要注意：确保继承是一种“...is a...”的关系；使用继承不要仅仅是为了代码复用或是体现多态。
49. 父类接口的脆弱性会给子类带来很大的麻烦。
50. 继承的一些问题（补充向）：
(1) 我们肯定是要重写一些什么的，但如果重写一切，那父类就不该是一个类而应该是一个接口；另外，如果不使用任何继承的方法，那继承也毫无意义。
(2) 我们不希望堆栈支持所有的父类方法，这是一个问题。
(3) 继承的父类与子类存在共有接口的耦合性，当父类接口发生改变时，子类接口也随之改变。
(4) 当子类创建对象的时候，就决定了其实现选择，无法实现动态的修改。
51. 接口定义了一种规约，而类实现了一种规约。
52. 含有继承关系的初始化：
    1. 从main()方法开始，加载父类，直到加载到根节点。
    2. 静态初始化根节点类，然后逐步静态初始化其子类。
    3. 所有的成员变量都赋初值为0/0.0/false/null。
    4. 父类的构造函数被调用。
    5. 成员变量按照文字顺序初始化。
    6. 构造函数的剩余部分被调用。
53. 新覆盖的方法会在对象创建之前被调用。
