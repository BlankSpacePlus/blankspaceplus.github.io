---
title: 可见性
date: 2021-03-13 00:04:04
summary: 本文从Java、C++、Python入手，探讨面向对象语言的可见性。
tags:
- 面向对象
- 软件工程
categories:
- 软件工程
---

# Java可见性

Java提供了private、protected、public三个关键词用作访问控制符，表示四种可见性。访问控制符用于控制一个类的成员是否可以被其他类访问。

| | 当前类访问权限 | 包访问权限(默认) | 子类访问权限 | 公开访问权限 |
|:----:|:----:|:----:|:----:|:----:|
| 关键词 | private | | protected | public |
| 同类可访问 | $√$ | $√$ | $√$ | $√$ |
| 同包可访问 | $×$ | $√$ | $√$ | $√$ |
| 子类可访问 | $×$ | $×$ | $√$ | $√$ |
| 全局可访问 | $×$ | $×$ | $×$ |  $√$ |

- 当前类访问权限：如果类里的属性、方法、构造器使用private修饰，则它只能在当前类的内部被访问。private最适合于修饰属性，因为比较符合“封装”的要求。
- 包访问权限(默认)：如果类里的属性、方法、构造器或一个类不使用任何访问控制符修饰，则它只能被相同包下的其他类访问。
- 子类访问权限：如果类里的属性、方法、构造器使用protected修饰，那么它既可以被同一个包里的其他类访问，也可以被不同包中的子类访问。用protected修饰，通常是希望子类重写该方法。
- 公开访问权限：如果类里的属性、方法、构造器或一个类使用public修饰，那么它可以被任何外部包下的类访问，前提是能够引入。

访问控制符的使用原则：
- 类里的绝大部分成员变量都应该使用private修饰，static修饰的类变量才应该采用public修饰。此外，有些只用于辅助实现该类的工具方法，工具方法也应该用private修饰。
- 如果某个类要用作其他类的父类，该类里包含的大部分方法可能仅希望被其子类重写，不想被外界调用，应该用protected修饰。
- 希望暴露出来给其他类自由调用的接口方法应该使用public修饰。构造器一般用public修饰，除了单例模式等情况。

```java
public class Rectangle {

    private int a, b;

    public Rectangle(int a, int b) {
        this.a = a;
        this.b = b;
    }

    public int getPerimeter() {
        return this.a + this.b;
    }

}
```

# C++可见性

C++提供了private、protected、public访问级别。

| 访问权限 | private | protected | public |
|:----:|:----:|:----:|:----:|
| 同类可访问 | $√$ | $√$ | $√$ |
| 子类可访问 | $×$ |$√$ | $√$ |
| 全局可访问 | $×$ | $×$ |  $√$ |

```cpp
class Square {
protected:
    int a;
public:
    explicit Square(int a) {
        this->a = a;
    }
    virtual int get_perimeter() const {
        return 4 * a;
    }
};

class Rectangle: Square {
private:
    bool checkRectangle() {
        return this->a != this->b;
    }
protected:
    int b;
public:
    Rectangle(int a, int b) : Square(a) {
        this->a = a;
        this->b = b;
    }
    int get_perimeter() const override {
        return 2 * (a + b);
    }
};
```

# Python可见性

Python默认可见性是public的。

```python
class Rectangle:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def get_perimeter(self) -> int:
        return 2 * (self.a + self.b)
```

前缀`__`可以表示private，若强行访问private成员，会出现`AttributeError: 'Rectangle' object has no attribute '...'`

```python
class Rectangle:
    def __init__(self, a, b):
        self.__a = a
        self.__b = b

    def get_perimeter(self) -> int:
        return 2 * (self.__a + self.__b)
```
