---
title: 对象的本质
date: 2021-03-17 16:23:53
summary: 对象是一个具有状态、行为和标识符的实体，结构和行为类似的对象被定义在它们共同的类中。
tags:
- 面向对象
- 软件工程
categories:
- 软件工程
---

# 对象的本质

> 对象是一个具有状态、行为和标识符的实体，结构和行为类似的对象被定义在它们共同的类中。

> 对象$\Leftrightarrow$实例

# 状态
操作一个对象的次序是重要的，这种行为依赖事件或依赖时间的原因是对象内部存在的状态。

> 对象的状态包括这个对象的所有属性（通常是静态的）以及每个属性当前的值（通常是动态的）。

属性是一种内在或独特的特征、特点、品质或特性，使一个对象区别于别的对象。
属性通常是静态的，因为这样的特征是不可更改的，是对象的本质。

所有的对象都有某种值，这个值可能是一个简单的数值，也可能代表另一个对象。
当对象的值是数值时，这是不受时间影响的、不可变化的、不可实例化的。
当对象的值是对象时，这是有存在时间的、可以变化的、可以实例化的，可以被创建、销毁和共享。

每个对象都有状态，这意味着每个对象都会在物理世界或计算机内存中占据一定的空间。

系统中的所有对象都封装了某种状态，系统中所有状态都由对象所封装。封装一个对象的状态只是开始，但并不足以让我们刻画出在开发过程中发现的这种抽象的全部含义。处于这个原因，必须考虑对象的行为。

同一个类的不同对象之间，一个对象不会与其他对象共享空间，虽然它们都有相同的属性，它们的状态具有共同的表现形式。

与暴露对象的状态相比，封装对象的状态是一项好的工程实践。

# 行为

> 行为是对象在状态改变和消息传递方面的动作和反应的方式。

对象的行为代表了它外部可见的活动。

操作是某种动作，一个对象对另一个对象执行这个操作，目的是获得反应。
Java语言中操作被称为方法，C++语言的操作被称为成员函数，Smalltalk语言的操作称为一个对象向另一个对象传递消息。

> 操作$\Leftrightarrow$消息传递

消息传递只是定义对象行为的一个方面，且对象的行为会受到其状态的影响。

> 一个对象的状态代表了它的行为累积效果。

很多对象没有静态状态，它们的状态包含了一些属性，这些属性的值在对象活动时被修改并被查询。一个对象的行为包括了其操作的总和。

一个操作代表了一个类提供给它对象的一种服务。最常见的五种操作：
- 公共操作：
    1. 修改操作：更改一个对象的状态的操作。
    2. 选择操作：访问一个对象的状态但并不更改这个状态的操作。
    3. 遍历操作：以一种定义良好的方式访问一个对象的所有部分的操作。
- 常见操作：
    1. 构造操作：创建一个对象并初始化它的状态的操作。
    2. 析构操作：释放一个对象的状态并销毁对象本身的操作。

Java只有构造操作，析构交给GC进行；C++支持构造操作和析构操作。

一个对象的所有方法共同构成了它的协议。
一个协议定义了对象允许的行为的封装，构成了这个对象完整的静态视图和动态视图。对大多数有用的对象来说，将这个较大的协议分成逻辑上的行为分组是有意义的。这些分组划分了对象的行为空间，表明了一个对象可以扮演的角色。
角色是一个对象戴上的一个面具，它定义了一种抽象与它的客户之间的契约。

> 责任意味着表达对象的一种目标以及它在系统中的位置。
> 一个对象的责任是它为支持的所有契约提供的全部服务。

一个对象的状态和行为共同决定了这个对象可以扮演的角色，这又实现了这种抽象的责任。

很多对象在它们的生命周期中扮演着许多不同的角色。
对象扮演的角色是动态的，同时又是互斥的。

我们常常从检查对象扮演的不同角色开始分析问题。在设计时，我们细化这些角色，设计出特定的操作，实现每个角色的责任。

对象中存在状态，这意味着操作调用的次序非常重要。其实，对象的行为可以通过一个等价的[有限状态机](https://blankspace.blog.csdn.net/article/details/114580869)来描述。

主动的对象具有自己的控制线程，而被动的对象则没有。
主动的对象通常是自动的，这意味着它们不需要其他对象操作，就能表现出一些行为；被动对象则不是主动的，只有在显式地调用它时，才会发生状态变化。
系统中的主动对象是控制的中心。如果并发系统包含多个控制线程，则通常会有多个主动对象；对于串行系统，通常至多有一个主动对象，可能由这个主要的对象负责一切，控制也可能分散在系统的被动对象中。

# 标识符

> 标识符是一个对象的属性，它区分这个对象和其他所有的对象。

> 大多数程序设计语言使用变量名来区分临时对象，混淆了定址能力和标识符。
> 大多数数据库系统使用标识符主键来区分持久对象，混淆了数据值和标识符。
> 不能区分对象的名称和对象本身，这点导致了面向对象编程中的许多错误。

维护创建的对象的标识符非常重要，这种标识符非常容易被丧失且无法恢复。

每个对象的唯一标识符是在对象的整个生命周期都被保持的，即使它的状态改变时也是如此。

一个对象可能有很多别名。
如$p_{1}$和$p_{2}$均指向$obj_{1}$，通过$p_{1}$修改$obj_{1}$的属性值则$p_{2}$指向的对象也发生了改变，这就是结构共享。
结构共享是面向对象编程的许多问题的根源。如果没有意识到通过别名来操作一个对象的副作用，常常会导致内存泄漏、非法内存访问甚至更糟糕的、未预期的状态改变。
如果我们销毁$p_{1}$所指向的对象$obj_{1}$，则$p_{2}$的值就没有意义了，$p_{2}$将成为悬空指针。
如果$p_{2}$原本指向$obj_{2}$，后来指向$obj_{1}$，则$obj_{2}$不具有名称，既没有直接名称也没有间接名称，JVM的GC机制可能会将其回收，但C++则会形成内存泄漏。
