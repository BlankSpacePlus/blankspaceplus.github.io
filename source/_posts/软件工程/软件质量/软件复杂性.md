---
title: 软件复杂性
date: 2023-02-19 21:43:34
summary: 本文分享软件复杂性的相关内容，包括软件本质的复杂性、代码的复杂性、软件体系结构的复杂性。
mathjax: true
tags:
- 软件质量
- 软件工程
categories:
- 软件工程
---

# 软件本质的复杂性

软件开发的本质体现在**其本身固有的困难中**，软件的本质问题是由软件固有的复杂性、一致性、可变性和不可见性所导致的。
- 软件本身就是复杂的，复杂性是**软件规模**（以代码行表示）的函数，以及组成软件产品构件之间相互依存关系的函数。软件复杂性随着软件应用领域的性质不同而不同，计算密集型$<$数据密集型。
- 一致性、可变性、不可见性加重了软件本身固有的困难。
- 一致性说的是软件必须与其基于的特定软硬件平台相一致，也必须与现有的信息系统相符合，并集成在一起。
- 可变性说的是业务过程和需求是不断变化的。
- 不可见性说的是负责输出的代码往往隐藏在不可见的程序语句、二进制代码库以及周边的系统软件中。

软件的本质困难定义了软件开发的不变事实，即软件是一种创造性开发行为的产品，不是制造业重复性行为的结果。**软件是开发出来的，不是批量制造出来的。**

# 软件代码的复杂性

## 圈复杂度

软件质量最重要的指标之一是圈复杂度(CYC)，它指的是代码的复杂程度。

圈复杂度是用于确定程序复杂度的软件指标。圈复杂度是源代码中决策数量的统计。圈复杂度越高，代码越复杂。复杂度高的代码很难测试。而且很可能会导致错误。

圈复杂度可以用于限制代码的复杂性，也可以用于确定所需测试用例的数量。

计算圈复杂度的公式：$CYC=E-N+2P$，$P$是流程图中断开连接的部分的数量（例如调用程序和子例程），$E$是边数（控制转移），$N$是节点数（仅包含一次控制转移的顺序语句组）。

圈复杂度等于逻辑运算符的数量，等同于决策数$+1$。

```c
void foo(int a, int b)
{
    int x;
    if (a && b)
    {
        x = 1;
    }
    else
    {
        x = 2;
    }
}
```

上面的代码段$CYC=2$。

```c
void foo(int a, int b)
{
    int x;
    if (a)
    {
        if (b)
        {
            x = 1;
        }
    }
    else
    {
        x = 2;
    }
}
```

上面的代码段$CYC=3$。

# 软件体系结构的复杂性

## 复杂性

复杂性具有不同的种类和形态，一种简明的度量是类之间通信路径的数量，通信路径是类之间存在的持久或暂时连接。

复杂性存在四种维度的解释：
- 问题复杂性：问题问题域本身的复杂性，也称为计算复杂性。
- 算法复杂性：目标是度量软件算法的效率。具有降低相关性应归于从算法到交互计算模式的转变。
- 结构复杂性：目标是建立软件结构之间的关系及易于维护和易于演化。对郎被应用到软件对象之间的依赖。
- 认知复杂性：度量理解软件所需要的努力，即捕获程序的逻辑流，并度量逻辑流的各种特性。

从适应能力的角度，认知复杂性度量可以增强可理解性质量，结构复杂性可以增强可维护性和可伸缩性质量。这两种度量是有关系的，对于低结构复杂性，认知复杂性的较小值虽然是必要不充分条件，这与修改代码的需求是一致的，在修改之前首先要理解它。

## 空间认知复杂性

计算机现代程序的可认知复杂性的最合适的度量就是空间复杂性度量，其目标是度量软件工程师为了构造软件的智力模型而必须在代码中移动的距离，空间复杂性的度量体现出不同的特点。

空间复杂性的度量有面向过程的理论和面向对象的理论，面向对象的理论基础很差且常常是错误的，而函数程序设计的空间复杂性公式则是存在的。

导出复杂性的值应该这么做：
1. 计算程序中每个函数的复杂性：$FC=\sum\limits_{i=1}^{total\_calls}{dist_{i}}$
2. 将这些值累加得到整个程序的复杂性：$PC=\sum\limits_{i=1}^{total\_functions}{FC_{i}}$

上述公式的主要弱点是以代码行计算距离。对于更现代的程序设计方法，代码行缺少相关性，当进行分析时也缺少将程序代码可视化的方法。另外，在这种情况下，代码行曲解了空间的含义。

## 结构复杂性

认知复杂性关注逻辑流，结构复杂性关注程序对象间的依赖。

> 一个依赖在模型元素之间定义了一种供应者/客户关系，对供应者的修改可能会影响客户模型的元素、依赖意味着没有供应者，客户的语义是不完整的。

> 如果更改提供服务的对象，则有必要修改此服务的客户对象，那么这两个系统对象之间就存在依赖。

如果系统中的所有依赖都被标识和理解，则说系统有适应性，即具有可理解性、可维护性、可伸缩性。适应性的一个必要条件是依赖可追踪，软件工程师的任务是减少依赖。

在软件系统中，可以根据不同粒度的对象（构件、包、类、方法）来识别依赖。位于低层次粒度上的较特殊对象的依赖会向上传递，在高层次粒度上产生依赖。依赖管理有必要更详细地研究代码，识别数据结构之间的所有关系以及软件对象之间的代码调用。

### 网络结构复杂性

网络的每条通信路径一般都允许类之间进行双向交互，其复杂性可以表示为${}_{net}CCD=n(n-1)$。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312211423222.png)

我们以类的数量而不是以对象的数量来测量复杂性。程序中，是对象而不是类发送消息给相同类或不同类的其他对象，这对于负责移交应用程序逻辑和管理程序变量和其他数据结构的程序员来说又引入了另外的困难。然而，这种困难在这种情况下不重要，可以忽略。

只有两个对象之间存在持久或瞬态连接，一个对象才可以向另一个对象发送消息。瞬态连接是在单个程序调用中解决的，在程序结构中直接可见，也可以不直接可见。只有在类模型中定义了连接，持久连接才存在。

### 层次结构复杂性

复杂性控制结构的解决方案是通过将类组织成类的合并结构来减少网络结构。用这种方法，类可以很自然地形成层，强调类之间的层次体系分解，而层的内部允许类似网络的交互。

分等级的层次组织通过限制类之间潜在交互路径的数量而降低复杂性，方法是：将类分到层中，只有同一层的内部及一层与层次体系中下面的相邻层之间才允许直接的类交互。

令$size(l_{i})$表示第$l_{i}$层的对象数，$l_{i}$为第$l_{i}$层的双亲数，$p_{j}(l_{i})$为第$l_{i}$层的第$j$个双亲。

$_{holarchy}CCD=\sum\limits_{i=1}^{n}{\frac{size(l_{i})\times(size(l_{i})-1)}{2}}+\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{l_{i}}(size(l_{i})\times{size(p_{j}(l_{i}))})$

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312211440473.png)
