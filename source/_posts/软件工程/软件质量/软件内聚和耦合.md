---
title: 内聚与耦合
date: 2020-03-03 15:08:34
summary: 本文分享内聚和耦合的理论知识、Demeter法则等内容。
tags:
- 软件质量
- 软件架构
- 软件工程
categories:
- 软件工程
---

# 模块独立性

模块独立性是指模块内部各部分及模块间的关系的一种衡量标准，由内聚和耦合来度量。

# 内聚

内聚是一个模块内部各成分之间相关联程度的度量。

类内聚是一个类内部自确定的程度，它测量类独立的强度。
一个高度内聚的类执行一个动作或者取得单一的目标，内聚越强越好。

## 内聚的分类

内聚的分类：
- **偶然内聚**：如果一个模块的各成分之间毫无关系，则称为偶然内聚，也就是说模块完成一组任务，这些任务之间的关系松散，实际上没有什么联系。
- **逻辑内聚**：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚，如一个模块读取各种不同类型外设的输入。
尽管逻辑内聚比偶然内聚合理一些，但逻辑内聚的模块各成分在功能上并无关系，即使局部功能的修改有时也会影响全局，因此这类模块的修改也比较困难。
- **时间内聚**：如果一个模块完成的功能必须在同一时间内执行（如系统初始化），但这些功能只是因为时间因素关联在一起，则称为时间内聚。
- **过程内聚**：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。<br>模块完成多个需要按一定的步骤一次完成的功能。例如：在用程序流程图设计模块时，若将程序流程图中的一部分划出各自组成模块，便形成过程内聚。
- **通信内聚**：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。
模块完成多个功能，各个功能都在同一数据结构上操作，这个模块的所有功能都是基于同一个数据结构。因此，它是一个信息内聚的模块。
- **顺序内聚**：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。
- **功能内聚**：模块的所有成分对于完成单一的功能都是必须的，则称为功能内聚。<br>功能内聚单一功能、独立性强、内部结构紧密，是最理想的内聚。

# 耦合

系统耦合始源于物理学，在物理学上耦合是指两个实体相互依赖于对方的一个量度。

软件工程的耦合表示两个子系统（或类）之间的关联程度。
当一个子系统（或类）发生变化时对另一个子系统（或类）的影响很小，则称它们是松散耦合的；反之，如果变化的影响很大时，则称它们是紧密耦合的。

耦合的强弱取决于模块间接间的复杂性、引用模块的位置和数据的传送方式等。设计时应尽量使模块间的耦合度小，模块间的耦合度直接影响系统的可理解性、可测试性、可靠性和可维护性。

## 耦合的分类

耦合的分类：
- **非直接耦合**
两个模块之间没有直接关系，彼此无任何交互，它们之间的联系完全是通过主模块的控制和调用来实现的。
- **数据耦合**
一个模块访问另一个模块时，彼此之间是通过简单数据参数（不是控制参数、公共数据结构或外部变量）来交换输入、输出信息的。一般系统中均需要存在这类耦合。
- **标记耦合**
一组模块通过参数表传递记录信息。这个记录是某一数据结构的子结构，可能包含着复合数据结构，而不是简单变量，例如含有若干数据项的数据记录。
- **控制耦合**
如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，如一个标志信息用于控制模块内部逻辑。
- **外部耦合**
一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，如I/O处理使所有I/O模块与特定的设备、格式和通信协议相关联。
- **公共耦合**
若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构共享的通信区、内存的公共覆盖区等。
- **内容耦合**
模块间存在着一个模块直接转入另一模块的内部或一个模块直接使用另一模块的数据或控制信息的情况：
    - 一个模块直接访问另一个模块的内部数据。
    - 一个模块不通过正常入口转到另一模块内部。
    - 两个模块有一部分程序代码重叠。（只可能出现在汇编语言中）
    - 一个模块有多个入口。

## 耦合的强弱

耦合的强弱取决于模块的划分是否合理以及模块之间接口的复杂程度。

划分模块时应尽量做到：
1. 排除模块之间不必要的联系。
2. 减少模块之间必不可少的联系的数量。
3. 松散模块之间联系的紧密程度。

这样做，就可以得到相互之间耦合比较弱、比较松散的模块划分。

# Demeter法则

虽然都在强调“高内聚低耦合”，但是必要的类耦合对于对象间的通信是必要的，只是它应该被限制在类的层次内，即层内耦合。

Demeter法则提供了限制类间任意通信的指南，说明了在类方法中允许什么样的消息目标。消息目标只能是下面选项之一：
- 对象的方法本身，如super、this等关键词代表的内容。
- 方法型构中作为参数的一个对象。
- 此对象的属性所引用的对象（包括属性的集合中所引用的对象）。
- 此方法创建的对象。
- 全局变量引用的对象。

为了限制继承带来的耦合，可以将第3条规则限制在类本身定义的属性上。此类继承的属性不能被用于标识消息的目标对象。此约束被称为Demeter增量法则。

实践方面，Demeter法则只是强迫执行良好的体系结构设计和体系结构框架原则的建议。
