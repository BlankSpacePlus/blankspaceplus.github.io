---
title: 闭包
date: 2023-03-25 12:52:29
summary: 本文分享程序设计中闭包的概念。
tags:
- 程序设计
categories:
- 程序设计
---

# 闭包

闭包（Closure）是一种在编程语言中常见的概念，也是一种高级编程技术，它可以帮助我们写出更加优雅、健壮、可维护的代码。

闭包指的是一个函数及其相关的引用环境。通常情况下，当一个函数执行完毕后，其中定义的所有变量和参数都会被销毁，但是在闭包中，这些变量和参数却可以被保留，并在函数执行后继续存在。这些变量和参数被称为自由变量或自由参数。

闭包的实现通常依赖于编程语言对于函数作用域和作用域链的支持。在支持闭包的编程语言中，当一个函数定义在另一个函数内部时，它可以访问其外部函数的所有变量和参数。如果该函数被返回并在外部函数之外执行，它仍然可以访问这些变量和参数，并在其执行期间保留它们的值。

闭包可以使代码更加灵活和可重用。例如，在JavaScript中，闭包常被用来创建函数工厂，这些函数工厂可以根据不同的参数和环境创建不同的函数。另一个例子是在Python中，闭包可以用来创建装饰器，这些装饰器可以对函数进行修饰并增加额外的功能。

# JavaScript闭包

在JavaScript中，闭包指的是有权访问另一个函数作用域中变量的函数，即使这个外部函数已经执行完毕。换言之，闭包就是在某个函数内部创建另一个函数，并且可以访问到所在函数的局部变量或者参数，形成了一个封闭的作用域。

简单来说，闭包就是函数和声明该函数的词法环境的组合。其中，词法环境指的是函数声明时所处的作用域链。闭包可以保留其词法环境中的变量和函数，使得外部函数执行后，内部函数仍能够访问这些变量和函数。这也是闭包名称的由来，因为内部函数可以“捕获”并存储外部函数的变量，就像一个背包（closure）一样。

当函数执行时，它创建了一个局部变量环境。当该函数返回并且其内部变量应该已经被销毁时，这些变量的值仍然可以被访问和使用，这就是闭包的精髓所在。

JavaScript 中的每个函数实际上都是一个闭包，因为每个函数在创建时都会捕获其所处的词法环境。如果嵌套函数在其父函数作用域之外被调用，则闭包将维护对其父函数变量的引用。

## JavaScript闭包实现

要创建闭包，需要满足以下两个条件：
1. 在函数内部定义另一个函数。
2. 内部函数必须能够访问外部函数的变量。

实现闭包的方法有两种：函数嵌套和函数工厂。

### 函数嵌套

函数嵌套是一种最基础的闭包实现方法。当一个函数内部嵌套了另一个函数时，后者就形成了闭包。

```javascript
function outer() {
    var a = 1;
    function inner() {
        console.log(a); // 输出1
    }
    return inner;
}

var f = outer();
f(); // 输出1
```

在上面的例子中，outer()函数创建并返回了一个内部函数inner()。由于inner()定义时声明了引用了outer()作用域下的变量a，所以调用f()时仍能够访问到a的值。

### 函数工厂

函数工厂是一种更为灵活的实现闭包的方式。通过将某个函数作为参数传入另一个函数，从而动态的生成新的闭包函数。

```javascript
function makeAdder(x) {
    return function(y) {
        return x + y;
    };
}

var add5 = makeAdder(5);
console.log(add5(2)); // 输出7

var add10 = makeAdder(10);
console.log(add10(2)); // 输出12
```

在上面的例子中，函数makeAdder(x)接收一个参数x，返回另一个匿名函数。这个匿名函数有一个自己的词法环境，并且可以访问到makeAdder(x)中的变量x。当我们调用makeAdder(5)时，会得到一个新的函数add5，它会对传入的参数加上5；同理，调用makeAdder(10)时，会得到另一个新的函数add10，它会对传入的参数加上10。

## JavaScript闭包应用

闭包在JavaScript中有很多重要的应用：
- 模块模式：通过返回函数和执行该函数来创建私有作用域（类似于私有方法）。这允许开发者封装代码，防止全局污染，并创建一个清晰的界面，以使对外部任何不必要的细节隐藏。
- 事件处理程序：用闭包编写的事件处理程序可以保持与元素相关联，而不必使用全局变量存储状态。
- 避免循环变量的共享：在循环中使用闭包可以避免循环变量的共享问题。如果在循环中使用 var 关键字，则会将变量提升到函数级别，因此每个迭代都会复写变量。但是，在循环中使用函数声明，可以创建每个闭包的新作用域，从而避免循环变量共享问题。
