---
title: 浅拷贝与深拷贝
date: 2023-03-27 00:57:01
summary: 本文分享浅拷贝与深拷贝的相关内容。
tags:
- 程序设计
categories:
- 程序设计
---

# 拷贝

拷贝（或复制）是一种编程中常见的操作，它允许我们创建一个新的变量，其值与另一个变量相同。拷贝可以分为两种类型：浅拷贝和深拷贝。

# 浅拷贝

浅拷贝是一种创建新对象的方法，该对象与原始对象共享内部对象的引用。在浅拷贝中，新对象只是原始对象的一个副本，并不是它的完全复制。当我们使用浅拷贝时，新对象中的某些属性和方法可能会发生变化，因为它们引用的是原始对象中的相同内部对象。

## Python实现浅拷贝

在Python中，可以使用切片操作或copy()函数来执行浅拷贝。

```python
a = [1, 2, 3, [4, 5]]
b = a.copy()
b[0] = 0
b[3][0] = 0
print(a)  # [1, 2, 3, [0, 5]]
print(b)  # [0, 2, 3, [0, 5]]
```

在上面的代码中，我们使用了copy()函数来执行浅拷贝，当我们改变b列表的第一个元素和内部列表的第一个元素时，a列表也随之发生了变化。

## Java实现浅拷贝

在Java中，可以使用Object类的clone()方法来实现浅拷贝。当我们调用一个对象的clone()方法时，它将创建并返回一个与原始对象相同的新对象，这个新对象与原始对象共享内部对象的引用。

例如，我们可以创建一个Person类，其中包含一个name属性和一个Address对象作为它的属性。然后，我们可以使用clone()方法来实现浅拷贝：

```java
public class Person implements Cloneable {
    private String name;
    private Address address;

    // constructors and getters/setters

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

在上面的代码中，我们实现了Cloneable接口，并重写了Object类的clone()方法。当我们调用Person对象的clone()方法时，它将返回一个新的Person对象，与原始对象共享Address对象的引用。

# 深拷贝

深拷贝是一种创建新对象的方法，该对象与原始对象完全独立。在深拷贝中，所有对象都是完全复制的，包括内部对象。这意味着，当我们使用深拷贝时，新对象与原始对象之间没有任何关联，它们的属性和方法也不会相互影响。

## Python实现深拷贝

在Python中，可以使用copy模块中的deepcopy()函数来执行深拷贝。

```python
import copy

a = [1, 2, 3, [4, 5]]
b = copy.deepcopy(a)
b[0] = 0
b[3][0] = 0
print(a)  # [1, 2, 3, [4, 5]]
print(b)  # [0, 2, 3, [0, 5]]
```

在上面的代码中，我们使用了deepcopy()函数来执行深拷贝。当我们改变b列表的第一个元素和内部列表的第一个元素时，a列表不会受到任何影响。

## Java实现深拷贝

在Java中，实现深拷贝的方法有很多，其中最常用的是使用序列化和反序列化来实现。这种方法需要将对象写入一个输出流中，并将其读回到一个新对象中。由于Java对象序列化和反序列化的过程中会创建一个完全独立的对象，因此可以实现深拷贝。

例如，我们可以创建一个Address类，其中包含一个city属性，然后使用序列化和反序列化来实现深拷贝：

```java
public class Address implements Serializable {
    private String city;

    // constructors and getters/setters

    public Address deepCopy() throws IOException, ClassNotFoundException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(this);
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        return (Address) ois.readObject();
    }
}
```

在上面的代码中，我们实现了Serializable接口，并创建了一个deepCopy()方法，该方法使用序列化和反序列化来实现深拷贝。当我们调用Address对象的deepCopy()方法时，它将返回一个与原始对象完全独立的新对象。

# 本文总结

浅拷贝和深拷贝都是非常有用的编程知识，了解二者各自的适用场景是重要的。如果我们想要创建一个独立的副本，而不是与原始对象共享内部对象的引用，那么我们应该使用深拷贝。而如果我们只需要一个对象的副本，并且不需要完全独立的对象，那么我们可以使用浅拷贝。
