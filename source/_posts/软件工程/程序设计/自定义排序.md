---
title: 自定义排序
date: 2023-03-25 21:12:15
summary: 本文分享自定义排序的实现方法，以C、C++、Java、Python为例。
tags:
- 程序设计
categories:
- 程序设计
---

# 自定义排序

自定义排序是一种排序方法，它允许用户自己定义元素的排序方式，而不是使用默认的排序方式。自定义排序可以基于不同的排序规则，例如按照元素的某个属性进行排序、按照特定的算法进行排序等等。

自定义排序通常涉及两个重要的概念：比较器和排序函数。比较器是一种函数，它接受两个元素作为参数，比较它们的大小，并返回一个整数值表示它们之间的关系。比较器通常是以lambda函数或函数指针的形式定义的。排序函数是一个使用比较器进行排序的函数，它接受一个元素列表作为参数，并返回一个排序后的列表。

下面的代码参照如下案例情景：**假设有一个包含多个人员信息的列表，每个人员信息都包括姓名、年龄和身高。现在需要按照身高从高到低的顺序对人员信息进行排序。**

# C自定义排序

在C语言中，可以使用标准库中的qsort函数进行排序。qsort函数也需要自定义比较函数来实现自定义排序。

自定义比较函数需要满足以下要求：
- 接收两个参数，类型与待排序的数组中元素的类型相同；
- 返回值为int类型，表示两个元素的大小关系。如果第一个元素比第二个元素小，则返回负数；如果两个元素相等，则返回0；如果第一个元素比第二个元素大，则返回正数。

C语言+实现自定义排序的步骤如下：
1. 定义一个结构体来存储人员信息，包括姓名、年龄和身高。
    ```c
    typedef struct {
        char name[20];
        int age;
        float height;
    } Person;
    ```
2. 定义一个比较函数，用于比较两个人的身高。
    ```c
    int compareByHeight(const void *a, const void *b) {
        Person *personA = (Person *) a;
        Person *personB = (Person *) b;
        if (personA->height < personB->height) {
            return 1;
        } else if (personA->height > personB->height) {
            return -1;
        } else {
            return 0;
        }
    }
    ```
    在这个比较函数中，我们首先将传入的指针转换为Person类型的指针，然后比较两个人的身高。如果personA的身高小于personB的身高，我们就返回1，表示personA应该排在personB的后面；如果personA的身高大于personB的身高，我们就返回-1，表示personA应该排在personB的前面；如果两个人的身高相同，我们就返回0，表示它们的顺序不变。
3. 使用C标准库中的qsort函数来对人员信息进行排序。
    ```c
    int main() {
        Person people[] = {
            {"Alice", 25, 1.75},
            {"Bob", 30, 1.80},
            {"Charlie", 28, 1.65},
            {"David", 22, 1.90},
            {"Eve", 27, 1.70}
        };
        int numPeople = sizeof(people) / sizeof(Person);
        qsort(people, numPeople, sizeof(Person), compareByHeight);
        for (int i = 0; i < numPeople; i++) {
            printf("%s, %d, %.2f\n", people[i].name, people[i].age, people[i].height);
        }
        return 0;
    }
    ```

需要注意的是，我们在比较函数中使用了类型转换，将传入的指针转换为Person类型的指针。这是因为在C语言中，qsort函数的第一个参数需要是void类型的指针，无法直接使用Person类型的指针。因此，我们需要在比较函数中将void类型的指针转换为Person类型的指针，以便进行比较。

# C++自定义排序

在C++中，可以使用STL中的sort函数进行排序。sort函数默认采用从小到大的排序方式，但是可以通过自定义比较函数来实现自定义排序。

自定义比较函数需要满足以下要求：
- 接收两个参数，类型与待排序的数组中元素的类型相同。
- 返回值为bool类型，表示两个元素的大小关系。如果第一个元素比第二个元素小，则返回true，否则返回false。

C++实现自定义排序的步骤如下：
1. 定义一个结构体来存储人员信息，包括姓名、年龄和身高。
    ```cpp
    struct Person {
        std::string name;
        int age;
        float height;
    };
    ```
2. 使用sort函数，自定义比较函数，实现按照身高从高到低的顺序对Person数组进行排序。
    ```cpp
    bool cmp(Person p1, Person p2) {
        return p1.height > p2.height;
    }
    ```
3. 使用C++中的STL中的sort函数来对人员信息进行排序。
    ```cpp
    int main() {
        std::vector<Person> people = {{"Alice", 25, 175.2}, {"Bob", 30, 180.5}, {"Charlie", 20, 170.1}};
        std::sort(people.begin(), people.end(), cmp);
        for (auto person : people) {
            std::cout << person.name << " " << person.age << " " << person.height << std::endl;
        }
        return 0;
    }
    ```

需要注意的是，这里使用了C++中的vector来存储Person对象，这是因为vector可以动态地调整大小，并且提供了begin和end等方法来实现迭代器操作。

# Java自定义排序

Java实现自定义排序通常需要借助于Comparator接口和Comparable接口。

## Comparator

Comparator接口定义了一个比较器，它允许开发者根据自己的需要定义对象的排序方式。Comparator接口中定义了一个compare方法，用于比较两个对象的大小，返回值为int类型，表示两个对象之间的大小关系。compare()的方法签名是`int compare(T o1, T o2)`。其中，T是要进行排序的元素类型。如果第一个对象比第二个对象小，则返回负数；如果两个对象相等，则返回 0；如果第一个对象比第二个对象大，则返回正数。

使用Comparator接口实现自定义排序的步骤如下：
1. 定义一个Comparator类，实现compare方法，根据需要比较元素的大小并返回结果。
    ```java
    public class PersonHeightComparator implements Comparator<Person> {
        @Override
        public int compare(Person p1, Person p2) {
            if (p1.getHeight() > p2.getHeight()) {
                return -1;
            } else if (p1.getHeight() < p2.getHeight()) {
                return 1;
            } else {
                return 0;
            }
        }
    }
    ```
2. 调用Collections.sort方法进行排序，并传入自定义的比较器对象。
    ```java
    List<Person> persons = new ArrayList<>();
    persons.add(new Person("Alice", 25, 180));
    persons.add(new Person("Bob", 30, 170));
    persons.add(new Person("Charlie", 35, 190));
    persons.add(new Person("David", 40, 160));
    PersonHeightComparator comparator = new PersonHeightComparator();
    Collections.sort(persons, comparator);
    ```

## Comparable

除了使用Comparator接口外，Java中还可以使用Comparable接口来实现自定义排序。Comparable接口是一个包含compareTo方法的接口，它定义了对象的自然顺序。compareTo方法的返回值为int类型，表示当前对象与参数对象之间的大小关系。

使用Comparable接口实现自定义排序的步骤如下：
1. 在需要进行排序的类中，实现Comparable接口，实现compareTo方法。
    ```java
    public class Student implements Comparable<Student> {
        private String name;
        private int age;
        private double height;

        public Person(String name, int age, double height) {
            this.name = name;
            this.age = age;
            this.height = height;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        public double getHeight() {
            return height;
        }
        
        @Override
        public int compareTo(Person otherPerson) {
            if (this.height < otherPerson.height) {
                return 1;
            } else if (this.height > otherPerson.height) {
                return -1;
            } else {
                return 0;
            }
        }
    }
    ```
2. 调用Collections.sort方法进行排序。
    ```java
    List<Person> personList = new ArrayList<>();
    personList.add(new Person("Tom", 20, 175.5));
    personList.add(new Person("Jerry", 25, 180.0));
    personList.add(new Person("Alice", 30, 165.2));
    Collections.sort(personList);
    ```

# Python自定义排序

Python实现自定义排序的步骤如下：
1. 定义一个比较器，用来比较两个人员信息的身高。
    ```python
    def height_comparator(person1, person2):
        if person1["height"] > person2["height"]:
            return -1
        elif person1["height"] < person2["height"]:
            return 1
        else:
            return 0
    ```
2. 定义一个排序函数，用来按照比较器的规则对人员信息进行排序。
    ```python
    def sort_persons_by_height(persons):
        return sorted(persons, key=lambda x: (x["height"]), cmp=height_comparator)
    ```
3. 调用排序函数对人员信息进行排序。
    ```python
    persons = [
        {"name": "Alice", "age": 25, "height": 180},
        {"name": "Bob", "age": 30, "height": 170},
        {"name": "Charlie", "age": 35, "height": 190},
        {"name": "David", "age": 40, "height": 160},
    ]
    sorted_persons = sort_persons_by_height(persons)
    print(sorted_persons)
    ```

输出结果：
<font color="blue">[{'name': 'Charlie', 'age': 35, 'height': 190}, {'name': 'Alice', 'age': 25, 'height': 180}, {'name': 'Bob', 'age': 30, 'height': 170}, {'name': 'David', 'age': 40, 'height': 160}]</font>
