---
title: 泛型
date: 2023-02-09 21:18:19
summary: 本文分享泛型的相关内容，主要包括Java的泛型和C++的模板。
tags:
- 程序设计
categories:
- 程序设计
---

# Java泛型

Java集合的设计者不知道使用者会在集合中存放什么类型的数据，而为每个类型的数据设计一个集合又是不现实的，因此集合内存储的对象类型是Object。这种设计是无奈之举，但对集合元素没有任何限制，不同类型的对象都可以插入集合中，取出时容易诱发java.lang.ClassCastException。

为了解决如上问题，Java5开始引入泛型(generic)的概念，即“参数化类型(parameterized type)”。例如，`List list  = new ArrayList();`改写为`List<String> list = new ArrayList<String>();`。Java的泛型允许在定义类、接口、方法时使用参数化类型，参数化类型将在声明变量、创建对象、调用方法时动态的指定，在整个接口、类的定义中当成类型使用。例如， `public class A<T>`。泛型的设计原则是，编译时没有出现warning或error的话，就不会遇到java.lang.ClassCastException。

由泛型类派生出的子类extends基类时，不能用到参数化类型，例如`public class B extends A<T>`是错误的。参数化类型可以代表变量、常量、表达式等数据类型。定义时可以声明参数化类型，调用方法时必须为它传入实际类型。

java.util.List\<Integer\>和java.util.List\<String\>其实是同样的类型：java.util.List。
```java
List<String> list1 = new ArrayList<String>();
List<Integer> list2 = new ArrayList<Integer>();
System.out.println(list1.getClass());
System.out.println(list2.getClass());
```

输出：
class java.util.ArrayList
class java.util.ArrayList

同样地，`instanceof java.util.List`是合法的，`instanceof java.util.List<Integer>`是不合法的。

根据上面的阐述，如果B类继承自A类，即`class B extends A`，java.util.List\<B\>并非继承自java.util.List\<A\>，二者的类型相同，都是java.util.List。与之不同的是，B[]可以与A[]之间形变互转。

当把一个具有泛型信息的对象赋给一个没有泛型信息的变量时，尖括号内的泛型信息会被丢弃，这被称为泛型擦除。

泛型类：
```java
public class ParameterizedCollection<T> {

    private T[] data;

    private int size;

    public ParameterizedCollection() {
    }

    @SuppressWarnings("unchecked")
    public ParameterizedCollection(T[] data) {
        this.data = (T[])new Object[data.length];
        System.arraycopy(data, 0, this.data, 0, data.length);
    }

}
```

由于上面的构造方法定义的不够“安全”，因此为了避免编译器警告，采用了`@SuppressWarnings("unchecked")`注解修饰，但这样可能导致运行时的java.lang.ClassCastException。

## 类型通配符

根据上文阐述，如下定义方法，传入List\<B\>会报错。
```java
public void method(List<A> list) {
    for (A a : list) {
        // TODO
    }
}
```

为了解决上面的问题，可以采用类型通配符`?`。例如：
```java
public void method(List<? extends A> list) {
    for (A a : list) {
        // TODO
    }
}
```

类型通配符最基础的用法是\<?\>。

\<? extends A\>表示类型通配符上限是A。编译器能够确定参数的类型上限，却不知道具体的类型，允许调用用到类型通配符上限作为返回值的方法(返回值的通配符替换成上限类型)，不允许调用用到类型通配符上限作为参数的方法。

\<? super B\>表示类型通配符下限是B。编译器能够确定参数的类型下限，却不知道具体的类型，允许调用用到类型通配符下限作为参数的方法(参数通配符替换成下限类型)，不允许调用用到类型通配符下限作为返回值的方法。

## 泛型上限

泛型也可以定义类似于\<? extends A\>的泛型上限，例如\<T extends A\>。甚至可以定义多个上限，用`&`分隔，接口上限必须在类上限之后。

类型通配符被设计用来支持灵活的派生。而泛型方法被设计用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的类型依赖关系，就不应该使用泛型方法。

## 类型推导

Java7支持泛型的类型推导，Java8和Java9对其略有增强。Java7允许在调用构造方法时，使用一对尖括号`<>`来代表泛型信息。Java8可以通过调用方法的上下文来推断泛型的目标类型。方法调用链中，推断得到的泛型可以传递到最后一个方法。Java9在创建匿名类时也可以使用类型推导。

```java
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
```

# C++泛型

C++模板是C++泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。

## 函数模板

```cpp
template <type_name type> return_type function_name(parameter_list)
{
    // 函数的主体
}
```

```cpp
#include <iostream>
#include <string>

using namespace std;

template <typename T>
inline T const& max (T const& a, T const& b, T const& c)
{
    return a < b ? (b < c ? c : b) : (a < c ? c : a);
}

int main ()
{
    int i1 = 3;
    int i2 = 2;
    int i3 = 1;
    cout << "max(a, b, c): " << max(i1, i2, i3) << endl;
    double f1 = 1.23;
    double f2 = 3.45;
    double f3 = 2.34;
    cout << "max(a, b, c): " << max(f1, f2, f3) << endl;
    string s1 = "Hello";
    string s2 = "Word";
    string s3 = "World";
    cout << "max(a, b, c): " << max(s1, s2, s3) << endl;
    return 0;
}
```

## 类模板

```cpp
template <class type> class class_name {
    // 类的主体
}
```

```cpp
#include <vector>

using namespace std;

template <class T>
class Template {
private:
    vector<T> data;
public:
    void function(const T& t);
};

template <class T>
void Template<T>::function(const T& t)
{
    data.push_back(t);
}
```
