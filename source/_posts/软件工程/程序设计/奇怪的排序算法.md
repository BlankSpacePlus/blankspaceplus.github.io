---
title: 奇怪的排序算法
date: 2019-10-25 09:39:55
summary: 本文分享一些奇怪的排序算法，例如睡眠排序、猴子排序。
mathjax: true
tags:
- 程序设计
categories:
- 程序设计
---

# 睡眠排序

排序算法一般是力求兼顾时间和空间的平衡，而睡眠排序算法却像是一个玩笑，当时间和空间两者消耗足够大，才能达到最终“精确”排序的目的。

## 基本思想

基于根据CPU的调度算法实现。

我们要对一组数据进行排序，不能存在负数值，这个数是多大，那么就在线程里睡眠它的10倍时间(ms)再加10，不是睡眠和它的数值一样大的原因是，当数值太小时，误差太大，睡眠的时间不比输出的时间少，那么就会存在不正确的输出结果。

## 实现原理

构造$n$个（$n$为待排序元素个数）自定义线程，它们和这$n$个数一一对应。

初始化后，线程都按照指定的时间开始休眠，等休眠时间到了以后结束休眠，等被执行的时候输出它对应的数。

这样，最小的数对应的线程最早醒来，这个数理论上最早被输出。

等所有线程都结束休眠并被执行完成，排序就结束了。

## 编程实现

线程类定义：

```java
public class SortThread extends Thread {  

    private int data = 0;  // 待排序的数
    
    public SortThread(int data) {  
        this.data = data;  
    }  
    
    @Override
    public void run() {  
        try {  
            // 睡眠指定的时间为数值的10倍再加上10
            sleep(data * 10 + 10);
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        // 输出该数
        System.out.println(data);  
    }  

}
```

算法实现：
```java
public static int[] sort(int[] array) {
    // 创建指定长度的线程数组
    SortThread[] threadList = new SortThread[array.length];  
    // 指定线程数组中每个线程的值data
    for (int i = 0; i < threadList.length; i++) {  
        threadList[i] = new SortThread(arr[i]);  
    } 
    // 启动每个线程
    for (SortThread thread : threadList) {  
        thread.start();  
    }     
}
```

# 猴子排序

## 无限猴子定理

推荐阅读：[无限猴子定理](https://zh.wikipedia.org/zh-hans/%E7%84%A1%E9%99%90%E7%8C%B4%E5%AD%90%E5%AE%9A%E7%90%86)

无限猴子定理：让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。

在这里，几乎必然是一个有特定含义的数学术语，“猴子”也不是一只真正意义上的猴子，它被用来比喻成一个可以产生无限随机字母序列的抽象设备。这个理论说明把一个很大但有限的数看成无限的推论是错误的。猴子精确地通过键盘敲打出一部完整的作品比如说莎士比亚的哈姆雷特，在宇宙的生命周期中发生的概率也是极其低的，但并不是零。

## 基本思想

把一个无序的数组进行乱排序(shuffle)，看其是否会有序。这个过程是个概率性事件，有可能一次之后就有序了，也有可能很多次后依然无序。

## 编程实现

线程类定义：
```java
public class SortThread extends Thread {

    //待排序列
	private List<Integer> array;
	
	//起始时间
	private Date startTime;
	
	//排序次数
	private int sum;
 
	public SortThread(List<Integer> array, Date startTime, int sum) {
		this.array = array;
		this.startDate = startDate;
		this.sum = sum;
	}
 
    @Override
	public void run() {
	    //使用默认随机源对列表进行置换，所有置换发生的可能性都是大致相等的(打乱重组)
		Collections.shuffle(array);
		//这个打印相当于toString()
		System.out.println(array);
		for (int i = 0; i < array.size()-1; i++) {
			if (array.get(i) < array.get(i+1)) {
				continue;
			} else {
				sum++;
				new SortThread(array, startDate, sum).start();
				//结束当前线程
				return;
			}
		}
		System.out.println("花费" + (new Date().getTime() - startTime.getTime()) + "ms时间\n排序数组元素个数:" + array.size() + "\n共进行了" + sum + "次");
	}
}
```

算法实现：
```java
public static List<Integer> sort(int[] array) {
    // int[] -> List<Integer>
    List<Integer> list = Arrays.stream(data).boxed().collect(Collectors.toList());
    int sum = 0;
    Date startTime = new Date();
    SortThread sortThread = new SortThread(list, startTime, sum);
    sortThread.run();
}
```
