---
title: 单例模式
date: 2020-09-26 21:07:46
summary: 本文分享单例模式的设计与实现。
tags:
- 设计模式
categories:
- 程序设计
---

# 单例模式

程序在运行时，通常要生成许多实例，但有时一个程序中的某一个类只能存在一个实例，这时就需要用到单例(Singleton)模式。单例模式保证了一个类仅有一个实例，并提供一个访问它的全局访问点。

通常，类的构造方法是public的。为了不能从外部随意调用构造方法创建实例，单例模式的构造方法是private的。为了向外部提供实例，还需要提供public方法。

如果一个类始终只能创建一个实例，那么它就是单例类。

单例模式的三个要点：
1. 单例类只能有一个实例。
2. 单例类必须自己创建自己的唯一实例。
3. 单例类必须给所有其他对象提供这一实例。

# 单例模式的实现

## 懒汉式

### 线程不安全

该方法通过私有构造方法、私有类属性、公开类方法，对外提供单一实例。

```java
public class LazySingleton {

    private static LazySingleton instance;

    private LazySingleton() {
        System.out.println("Lazy Singleton has been created!");
    }

    public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }

}
```

### 线程安全

简单地引入synchronized加锁，保障了线程安全，性能不理想。

```java
public class LazySingleton {

    private static LazySingleton instance;

    private LazySingleton() {
        System.out.println("Lazy Singleton has been created!");
    }

    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }

}
```

## 饿汉式

该方法基于类加载机制避免了多线程的同步问题，是线程安全的。该方法在类加载时就初始化单例，浪费内存。

```java
public class EagerSingleton {

    private static EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {
        System.out.println("Eager Singleton has been created!");
    }

    public static EagerSingleton getInstance() {
        return instance;
    }

}
```

## 双重校验锁

简单地使用synchronized同步方法会导致性能较差，基于同步代码块的实现能优化性能。

`instance == null`判断两次。外层判断是为了过滤已经实例化的情况，极大地减少用synchronized加锁的情况；内层判断是基本的实现代码块，不赘述。

推荐阅读：[操作系统的进程管理](https://blankspace.blog.csdn.net/article/details/128746107)

若想初始化类的实例，则需要获得该类的Class对象，即`DoubleCheckSingleton.class`。因为涉及对Class对象的并发竞争，需要用synchronized对Class对象加锁，保证任何时刻只能有一个线程可以获得Class对象的锁。临界区是以下代码：
```java
if (instance == null) {
    instance = new DoubleCheckSingleton();
}
```

volatile可以在单例双重校验中实现可见性和禁止指令重排序，从而保证安全性。
- 可见性：volatile适合读多写少的场景。volatile变量被修改之后，对其他线程立即可见，即写线程强制刷新到内存、读线程强制从内存读取。但是，volatile只保证了共享对象singleton的可见性，而`instance = new DoubleCheckSingleton();`不具备原子性，因此仍然需要synchronized。
- 禁止指令重排序：有时，编译器和处理器为了优化程序执行的性能，会对指令序列进行重排序，导致CPU执行指令的顺序可能和程序代码的顺序不一致。

```java
public class DoubleCheckSingleton {

    private volatile static DoubleCheckSingleton instance;

    private DoubleCheckSingleton() {
        System.out.println("Double Check Singleton has been created!");
    }

    public static DoubleCheckSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }

}
```

# 单例模式的测试

基于JUnit5的单元测试，通过验证对象是否完全相等即可。

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SingletonTest {

    @Test
    public void lazySingletonTest() {
        LazySingleton singleton1 = LazySingleton.getInstance();
        LazySingleton singleton2 = LazySingleton.getInstance();
        Assertions.assertEquals(singleton1, singleton2);
    }

    @Test
    public void eagerSingletonTest() {
        EagerSingleton singleton1 = EagerSingleton.getInstance();
        EagerSingleton singleton2 = EagerSingleton.getInstance();
        Assertions.assertEquals(singleton1, singleton2);
    }

    @Test
    public void doubleCheckSingletonTest() {
        DoubleCheckSingleton singleton1 = DoubleCheckSingleton.getInstance();
        DoubleCheckSingleton singleton2 = DoubleCheckSingleton.getInstance();
        Assertions.assertEquals(singleton1, singleton2);
    }

}
```
