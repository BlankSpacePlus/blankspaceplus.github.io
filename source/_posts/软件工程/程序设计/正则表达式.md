---
title: 正则表达式
date: 2023-02-09 00:10:30
summary: 本文分享正则表达式的相关内容，介绍Java对正则表达式的支持。
tags:
- 程序设计
categories:
- 程序设计
---

# 正则表达式

正则表达式(Regular Expression)(***regex***)是使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，可用于所有文本搜索和文本替换的操作。

# 正则表达式通则

## 合法字符

正则表达式支持的合法字符包括：
- 任意字符
- 八进制整数对应的字符，以`\0`开头
- 十六进制整数对应的字符，以`\x`开头，2位(二进制8位)
- 十六进制整数对应的Unicode字符，以`\x`开头，4位(二进制16位)
- 制表符，`\t`，`\u0009`
- 换行符，`\n`，`\u000A`
- 回车符，`\r`，`\u000D`
- 换页符，`\f`，`\u000C`
- 警报符，`\a`，`\u0007`
- Escape符，`\e`，`\u001B`
- Ctrl+X组合控制符：`\cX`，其中X必须是[A-Z]|[a-z]之一

## 特殊字符

- `$`：匹配一行的结尾
- `^`：匹配一行的开头
- `()`：匹配子表达式的开头结尾
- `[]`：匹配中括号表达式的开头结尾
- `{}`：标记子表达式出现的频次
- `*`：指定前面的子表达式可以出现零次或多次
- `+`：指定前面的子表达式可以出现一次或多次
- `?`：指定前面的子表达式可以出现零次或一次
- `.`：匹配换行符以外的任何单字符
- `\`：转义下一个字符，指定八进制/十六进制字符
- `|`：两项间二选一

需要专门匹配以上字符时，应该使用`\`转义，例如`\$`、`\^`。Java字符串中的反斜线本身需要转义，因此`\\`相当于`\`，例如匹配`\`的正则表达式是`\\`但匹配串是`"\\\\"`。

## 专用通配符

- `\d`：匹配阿拉伯数字0-9
- `\D`：匹配非阿拉伯数字
- `\s`：匹配所有空白字符，包括空格、制表符、回车符、换页符、换行符
- `\S`：匹配所有非空白字符
- `\w`：匹配所有单词字符，包括阿拉伯数字0-9、小写英文字母a-z、大写英文字母A-Z、下划线_
- `\W`：匹配所有非单词字符

## 子表达式

子表达式需要`()`括起来，小括号起到分隔作用，类似于运算表达式中的小括号。不必需的时候也可以为子表达式加上括号，看起来更直观。

子表达式可以嵌套，形成更复杂的表达式。

## 中括号表达式

整个中括号表达式只能匹配一个字符。

- 枚举：中括号内简单的字符罗列表示枚举，`[abc]`表示a、b、c，`[acd]`表示a、c、d
- 范围：中括号内横杠`-`连接的两个字符间的闭区间范围，`[a-z]`表示a~z的26个小写英文字符
- 并集：`[a-ce-f]`表示a、b、c、e、f
- 交集：`[a-z&&[cd]]`表示c、d
- 补集：`[^abc]`表示非a、b、c的任意字符，`[^a-z]`表示非a-z的任意字符

## 出现次数

- `X+`：X表达式出现1次或多次。
- `X*`：X表达式出现0次或多次。
- `X?`：X表达式出现0次或1次。
- `X{n}`：X表达式出现n次。
- `X{n,}`：X表达式最少出现n次。
- `X{n,m}`：X表达式最少出现n次，最多出现m次。

# Java正则匹配

Java的正则表达式按照字符串处理，因此转义的每个`\`要多重复一次。

## 匹配模式

- Greedy模式：默认采用的模式，一直匹配下去直至无法匹配。
- Reluctant模式：匹配最少的字符。
- Possessive模式：只有Java支持的模式。

| Greedy模式 | Reluctant模式 | Possessive模式 | 说明 |
|:----:|:----:|:----:|:----:|
| `X?` | `X??` | `x?+` | X表达式出现0次或1次 |
| `X*` |`X*?` | `X*+` | X表达式出现0次或多次 |
| `X+` | `X+?` | `X++` | X表达式出现1次或多次 |
| `X{n}` | `X{n}?` | `X{n}+` | X表达式出现n次 |
| `X{n,}` | `X{n,}?` | `X{n,}+` | X表达式最少出现n次 |
| `X{n,m}` | `X{n,m}?` | `X{n,m}+` | X表达式最少出现n次，最多出现m次 |

## 匹配方法

Java对正则表达式的支持类在java.util.regex包下，主要的类是java.util.regex.Matcher和java.util.regex.Pattern。

关键的匹配方法API包括：
- `find()`：判断待匹配字符串是够包含与Pattern匹配的子串。
- `group()`：获取上一次与Pattern匹配的子串。注意，并非匹配第一次与Pattern匹配的子串，必须find()过的才算。
- `start()`：获取上一次与Pattern匹配的子串在待匹配字符串中的开始位置。
- `end()`：获取上一次与Pattern匹配的子串在待匹配字符串中的结束位置+1。
- `lookingAt()`：判断待匹配字符串前缀与Pattern是否匹配。
- `matches()`：判断待匹配字符串整体与Pattern是否匹配。
- `reset()`：将现有Matcher对象应用于新的字符序列。

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RegexTest {

    @Test
    public void findTest() {
        Pattern pattern = Pattern.compile("\\w+");
        Matcher matcher = pattern.matcher("Attention is all you need");
        Assertions.assertTrue(matcher.find());
    }

    @Test
    public void groupTest() {
        Pattern pattern = Pattern.compile("\\w+");
        Matcher matcher = pattern.matcher("Attention is all you need");
        matcher.find();
        matcher.find();
        Assertions.assertEquals("is", matcher.group());
        Assertions.assertEquals(10, matcher.start());
        Assertions.assertEquals(12, matcher.end());
    }

    @Test
    public void lookingAtTest() {
        Pattern pattern = Pattern.compile("\\s+");
        Matcher matcher = pattern.matcher("Attention is all you need");
        Assertions.assertFalse(matcher.lookingAt());
    }

    @Test
    public void matchesTest() {
        Pattern pattern = Pattern.compile("(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])");
        Matcher matcher = pattern.matcher("127.0.0.1");
        Assertions.assertTrue(matcher.matches());
    }

}
```

## IPv4地址正则匹配

IPv4地址的格式是`nnn.nnn.nnn.nnn`，其中每一个nnn为0\~255之间的整数。

匹配规则是`(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])`，其中反复出现的一个子结构是`25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9]`，它匹配的是0\~255。
`[0-9]`表示0\~9的任一整数，`[01]`表示0或1，`|`表示或，而`?`表示出现0次或1次。
所以这个子结构可以解释为：0\~9或10\~99或100\~199或200\~255，综合起来就是0\~255。
值得注意的是毕竟不能把`1`表示为`001`，所以这里的处理稍显复杂。

假设用A代指`25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9]`，剩下的内容变成了`(?:(?:A)\.){3}(?:A)`。
`(?:)`是一个结构，表示非捕获分组。
`()`表示捕获分组，`()`会把每个分组里的匹配的值缓存，使用`$n`（n是一个整数，表示第n个捕获组的内容）可用。
但使用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用`?:`放在第一个选项前（即`(?:)`）来消除这种副作用。

`.`表示除换行符外的任何字符，所以需要加反斜线以转义点号，即为`\.`。
因此`(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.)`的含义是一个0\~255的整数加上一个点号。

而`{3}`表示将之前的内容重复3次，即将一个0\~255的整数加上一个点号这个内容重复3次。
最后再补上一个0\~255的整数，即为所求。

# JavaScript正则匹配

JavaScript正则表达式的语法规则是：`/正则表达式主体/匹配模式(可选)`，不需要被字符串的双引号引起来。

JavaScript中，正则表达式通常用于字符串的`search()`方法和`replace()`方法：
- `search()`：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。
- `match()`：找到一个或多个正则表达式的匹配。
- `replace()`：在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。
- `split()`：把字符串分割为字符串数组。

## 匹配模式

JavaScript支持三种匹配模式：
- `i`：执行对大小写不敏感的匹配。
- `g`：执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
- `m`：执行多行匹配。

## 匹配规则补充

- `X$`：匹配任何结尾为X的字符串。
- `^X`：匹配任何开头为X的字符串。
- `?=X`：匹配任何其后紧接指定字符串X的字符串。
- `?!X`：匹配任何其后没有紧接指定字符串X的字符串。

## 匹配方法

Java对正则表达式的支持类是RegExp。

RegExp可用的三个方法：
- `exec`：检索字符串中指定的值。返回找到的值，并确定其位置。
- `test`：检索字符串中指定的值。返回true或false。
- `toString`：返回正则表达式的字符串。

# 正则表达式辅助工具

- [正则表达式可视化工具](https://wangwl.net/static/projects/visualRegex#)
