---
title: 矩阵的特征值和特征向量
date: 2021-03-01 13:03:00
summary: 本文介绍矩阵的特征值和特征向量，并用numpy实现和验证。
mathjax: true
tags:
- 线性代数
- Python
categories:
- 计算机科学的数学基础
---

# 线性代数理论分析

设$A$是$n$阶方阵,  如果数$\lambda_{0}$和$n$维非零列向量$\xi$满足关系式$A\xi=\lambda_{0}\xi$，则称$\lambda_{0}$为A的特征值，$\xi$为A的属于$\lambda_{0}$的一个特征向量。

设$A$是$n$阶方阵，$\lambda$是参数，则行列式$\det(\lambda{E}-A)=\begin{vmatrix} \lambda-a_{11} & -a_{12} & \ldots & -a_{1n} \\ -a_{21} & \lambda-a_{22} & \ldots & -a_{2n} \\ \vdots & \vdots & \ddots & \vdots \\ -a_{n1} & -a_{n2} & \ldots & \lambda-a_{nn} \end{vmatrix}$称为方阵$A$的特征多项式。称$\det(\lambda{E}-A)=0$为方阵$A$的特征方程。$A$的特征值就是特征方程的解，$n$阶方阵$A$有$n$个特征值。$A$的属于特征值$\lambda_{i}$的特征向量就是齐次线性方程组$(\lambda_{i}E-A)x=0$的所有非零解。

# Numpy编程实现

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca28898bde6d4737a6a7dfa02613fc59.png)

推荐阅读：[Numpy操作向量和矩阵](https://blankspace.blog.csdn.net/article/details/104074290)

Numpy库的`numpy.linalg.eig()`可以计算特征值和特征向量。

```python
# 加载numpy库
import numpy as np

# 创建一个求解特征值、特征向量的矩阵
matrix = np.array([[1, -1, 3], [1, 1, 6], [3, 8, 9]])

# 计算特征值和特征向量
eigen_values, eigen_vectors = np.linalg.eig(matrix)
```

查看计算所得的特征值和特征向量：
```python
# 查看特征值
print(eigen_values)
print(type(eigen_values))

# 查看特征向量
print(eigen_vectors)
print(type(eigen_vectors))
```

输出结果：
[13.55075847  0.74003145 -3.29078992]
\<class 'numpy.ndarray'\>
[[-0.17622017 -0.96677403 -0.53373322]
 [-0.435951    0.2053623  -0.64324848]
 [-0.88254925  0.15223105  0.54896288]]
\<class 'numpy.ndarray'\>

可见，特征值的结果类型是一维`numpy.ndarray`，特征向量的结果类型是二维`numpy.ndarray`。

验证方法按照标准定义来，对$A$的每个特征值$\lambda_{i}$及其对应的特征向量$\xi_{i}$，$A\xi_{i}=\lambda_{i}\xi_{i}$。
```python
for i in range(eigen_values.shape[0]):
    # 逐一取出的特征值
    lambda_data = eigen_values[i]
    # 逐一取出对应的特征向量
    xi_vector = eigen_vectors[:, i:i + 1]
    # n×n矩阵和n×1向量相乘
    print(matrix.dot(xi_vector))
    # λ数值和n×1向量乘得数量积
    print(lambda_data * xi_vector)
    # 换行
    print()
```

特征向量应该按列取，即`eigen_vectors[:, i:i + 1]`。

矩阵和向量相乘不能用`*`，要用`.dot()`求得：`matrix.dot(xi_vector)`。

尽管看起来等号两侧的结果向量相等，但还是可以用`numpy.array_equal()`对比一下：`np.array_equal(matrix.dot(xi_vector), (lambda_data * xi_vector))`。遗憾的是，并不总是True，这可能是浮点运算误差所致。
