---
title: 离散数学实验汇总
date: 2020-09-26 21:40:34
summary: 本文分享离散数学课程实验。
mathjax: true
tags:
- 离散数学
categories:
- 计算机科学的数学基础
---

# 实验1：自动逻辑推理问题求解

一个公安人员审查一件盗窃案，已知的事实如下：
1. A或B盗窃了x;
2. 若A盗窃了x，则作案时间不能发生在午夜前；
3. 若B证词正确，则在午夜时屋里灯光未灭；
4. 若B证词不正确，则作案时间发生在午夜前；
5. 午夜时屋里灯光灭了；

求解谁是盗贼，并打印输出。
要求封装逻辑表达式函数（析取、合取）。

下面给出了两种大致相同的代码实现（Java）：
个人感觉第二个更好一点点。

```java
public class Reasoning {
    
    //int转boolean
    public static boolean changeType(int var) {
        if (var == 1) {
            return true;
        } else {
            return false;
        }
    }
    
    //合取
    public static boolean Conjunction(boolean var1, boolean var2, boolean var3, boolean var4, boolean var5){
        if (var1 && var2 && var3 && var4 && var5){
            return true;
        }else{
            return false;
        }
    }

    //析取
    public static boolean Disjunctive(boolean var1, boolean var2){
        if ((var1 || var2) == true){
            return true;
        }else{
            return false;
        }
    }
    
    //逻辑推理最终表达式真伪
    public static boolean judge(boolean var1, boolean var2, boolean var3, boolean var4, boolean var5){
        if (Conjunction(Disjunctive(var1, var2), Disjunctive(!var1, !var3), Disjunctive(!var4, !var5), Disjunctive(var4, var3), var5)) {
            return true;
        } else {
            return false;
        }
    }
    
    //输出结果
    public static void getResult(boolean var1, boolean var2, boolean var3) {
        if (var1 == true) {
            if (var2 == true) {
                if (var3 == false) {
                    System.out.println("结论是:A偷窃了x");
                    System.exit(0);
                }
            } else {
                if (var3 == true) {
                    System.out.println("结论是:B偷窃了x");
                    System.exit(0);
                }
            }
        }
    }
    
    //main方法
    public static void main(String[] args) {
        boolean A, B, C, D, E;
        for (int a = 0; a <= 1; a++) {
            for (int b = 0; b <= 1; b++) {
                for (int c = 0; c <= 1; c++) {
                    for (int d = 0; d <= 1; d++) {
                        for (int e = 0; e <= 1; e++) {
                            A = changeType(a);
                            B = changeType(b);
                            C = changeType(c);
                            D = changeType(d);
                            E = changeType(e);
                            getResult(judge(A, B, C, D, E), A, B);
                        }
                    }
                }
            }
        }
    }

}
```

```java
public class Reasoning2 {
    
    private static final boolean[] array = {false, true};
    
    //合取
    public static boolean Conjunction(boolean var1, boolean var2,
            boolean var3, boolean var4, boolean var5){
        if (var1 && var2 && var3 && var4 && var5){
            return true;
        }else{
            return false;
        }
    }

    //析取
    public static boolean Disjunctive(boolean var1, boolean var2){
        if ((var1 || var2) == true){
            return true;
        }else{
            return false;
        }
    }
    
    //逻辑推理最终表达式真伪
    public static boolean judge(boolean var1, boolean var2, 
            boolean var3, boolean var4, boolean var5){
        if (Conjunction(Disjunctive(var1, var2), Disjunctive(!var1, !var3),
                Disjunctive(!var4, !var5), Disjunctive(var4, var3), var5)) {
            return true;
        } else {
            return false;
        }
    }
    
    //输出结果
    public static void getResult(boolean var1, boolean var2, boolean var3) {
        if (var1 == true) {
            if (var2 == true) {
                if (var3 == false) {
                    System.out.println("结论是:A偷窃了x");
                    System.exit(0);
                }
            } else {
                if (var3 == true) {
                    System.out.println("结论是:B偷窃了x");
                    System.exit(0);
                }
            }
        }
    }
    
    //main方法
    public static void main(String[] args) {
        for (boolean a : array) {
            for (boolean b : array) {
                for (boolean c : array) {
                    for (boolean d : array) {
                        for (boolean e : array) {
                            getResult(judge(a, b, c, d, e), a, b);
                        }
                    }
                }
            }
        }
    }

}
```

均输出：

```java
结论是:B偷窃了x
```

自行验证，结果OK。

# 实验2：三人表决器设计与实现

这个表决器就是支持/反对/弃权，由三个人投票，多数人支持则通过，可以弃权（输入不合法默认弃权）。
其实本问题可以作为离散数学中的基本命题逻辑问题，也可以作为一个最基本的电路逻辑问题。
这里我们只用最基本的逻辑来实现这个表决器，而且要求必须抽取出合取、析取的方法封装起来使用。

```java
import java.util.*;

public class Voter{
    
    //int转boolean
    public static boolean changeType(int var) {
        if (var == 1) {
            return true;
        } else {
            return false;
        }
    }

    //合取
    public static boolean Conjunction(boolean var1, boolean var2){
        if (var1 && var2){
            return true;
        }else{
            return false;
        }
    }

    //分析主析取范式(┓A∧B∧C) ∨(A∧┓B∧C)∨(A∧B∧┓C)∨(A∧B∧C)的真值
    //只要ABC中有至少两个同意（输入true）就可以
    public static boolean Disjunctive(boolean var1, boolean var2, boolean var3){
        return (var1 || var2 || var3);
    }
    
    //输出表决结果
    public static void getResult(boolean var) {
        if (var == true) {
            System.out.println("恭喜，表决通过");
        } else {
            System.out.println("很遗憾，表决没有通过");            
        }
    }

    public static void main(String[] args) {
        boolean a = false, b = false, c = false;
        Scanner scan = new Scanner(System.in);
        for (int i = 0; i < 3; i++) {
            System.out.println("请输入您的表决值！1代表同意，0代表反对，其余输入均无效");            
            int x = scan.nextInt();
            if (x == 0 || x == 1) {
                switch (i) {
                    case 0:
                        a = changeType(x);
                        break;
                    case 1:
                        b = changeType(x);
                        break;
                    case 2:
                        c = changeType(x);
                        break;
                }
            } else {
                System.out.println("您的输入错误，表决无效");
            }
        }
        
        getResult(Disjunctive(Conjunction(a, b), Conjunction(a, c), Conjunction(b, c)));
        scan.close();
    }

}
```

# 实验3：旅行线路规划问题

## 实验要求

1.实验目的：加深图的汉密尔顿路及最短路径的理解与应用
2.实验内容：搜索某旅游城市地图（至少包含10个景点），随机选取出发地点，基于图论理论建立模型，给出合理的旅行路线。要求考虑时间、成本等因素。
3.实验原理和方法：
(1) 不多于3名同学一组，选择某一旅游城市为研究对象，考察该城市至少10个景点在地图中的位置，根据景点间的路径绘制路线图。
(2) 考虑两个景点间的距离、交通工具等因素，设置路线权重。
(3) 随机从任意一点出发，基于图论理论建立模型，给出合理的旅行路线。
4.参考案例
该问题是一个典型的旅行商问题，通常用加权图表示。如果已知顶点u和顶点v的距离是r，连接u和v这两点权重就是r。图中一个圈C的权指的是C中所有边的权重之和。为了解决旅行商问题，我们需要确定加权图中哈密尔顿图的最小权值。以推销员在城市间巡回旅行为例，介绍该问题的求解。
问题：一个推销员计划在一些城市间巡回旅行，城市间的距离如图所示的加权图G，那么他这次旅行的最小距离是多少？
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020031810141177.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NjMxOA==,size_16,color_FFFFFF,t_70)
解答：因为图G是5阶图，因此G中有(5-1)!/2=12个哈密尔顿圈，每个圈及其权重列表如下：
<table>
<tr><th>哈密尔顿圈</th>	<th>圈的权重</th></tr>
<tr><td>S1=(C1,C2,C3,C4,C5,C1)</td><td>7+10+8+6+12=43</td></tr>
<tr><td>S2=(C1,C2,C3,C5,C4,C1)	</td><td>7+10+4+6+9=36</td></tr>
<tr><td>S3=(C1,C2,C4,C3,C5,C1)	</td><td>44</td></tr>
<tr><td>S4=(C1,C2,C4,C5,C3,C1)</td><td>41</td></tr>
<tr><td>S5=(C1,C2,C5,C3,C4,C1)	</td><td>42</td></tr>
<tr><td>S6=(C1,C2,C5,C4,C3,C1)	</td><td>46</td></tr>
<tr><td>S7=(C1,C3,C2,C4,C5,C1)</td><td>52</td></tr>
<tr><td>S8=(C1,C3,C2,C5,C4,C1)	</td><td>50</td></tr>
<tr><td>S9=(C1,C3,C4,C2,C5,C1)	</td><td>58</td></tr>
<tr><td>S10=(C1,C3,C5,C2,C4,C1)</td><td>51</td></tr>
<tr><td>S11=(C1,C4,C2,C3,C5,C1)</td><td>48</td></tr>
<tr><td>S12=(C1,C4,C3,C2,C5,C1)	</td><td>53</td></tr>
</table>
因此，从表中可读出哈密尔顿圈的最小权重为36.为了获得此权重，G中的点按照C1,C2,C3,C5,C4,C1或者C1,C4,C5,C3,C2,C1的顺序访问。
5.实验过程：
6.遇到的问题和解决方案：

## 数据

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200318101211315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NjMxOA==,size_16,color_FFFFFF,t_70)

## 图的表示

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200318101333946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NjMxOA==,size_16,color_FFFFFF,t_70)

## 输入数据

```sql
//运行时将下面这些信息直接复制到控制台, 回车即可:(本行不要录入)
10
北京
天津
上海
重庆
呼市
乌鲁木齐
拉萨
银川
南宁
哈尔滨
125
1239
3026
480
3300
3736
1192
2373
1230
1150
1954
604
3330
3740
1316
2389
1207
1945
1717
3929
4157
2092
1892
2342
1847
3202
2457
1570
993
3156
2825
3260
716
2657
1710
2668
2111
4279
4531
2547
3431
4967
2673
2422
3592
```

## 代码

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Point{
    int selected;
    int id;
    String name;
    Point(String name){
        this.name = name;
    }
}

class Edge{
    Point[] points = new Point[2];
    int value;
    Edge(int value){
        this.value = value;
    }
}

public class Hamilton {

    private static Edge[] allEdges;

    public static void main(String[] args){

        Scanner sc = new Scanner(System.in);
        System.out.println("Please enter the number of the city: ");
        int n = sc.nextInt();
        int m = (n - 1) * n / 2;

        Point[] allPoints = new Point[n];
        allEdges = new Edge[m];

        for (int i = 0; i < n; i++) {
            System.out.printf("Please enter the name of the city %d: ", i+1);
            allPoints[i] = new Point(sc.next());
            allPoints[i].id = i;
        }

        int count = 0;
        for(int i = 0; i < n; i ++){
            for (int j = i + 1; j < n; j++) {
                if(i != j){
                    System.out.printf("PLease enter the value between %s and %s: ", allPoints[i].name, allPoints[j].name);
                    int v = sc.nextInt();
                    allEdges[count] = new Edge(v);
                    allEdges[count].points[0] = allPoints[i];
                    allEdges[count].points[1] = allPoints[j];
                    count ++;
                }
            }
        }

        System.out.println();
        
        List<Point> rst = new ArrayList<>();

        Point start = allPoints[0];
        rst.add(start);
        start.selected = 1;
        int c = 0;

        while(c < n -1){
            Point next = getMinPoint(start, allPoints);
            rst.add(next);
            next.selected = 1;
            start = next;
            c ++;
        }

        rst.add(allPoints[0]);

        for (int i = 0; i < rst.size(); i++) {
            if(i == rst.size()-1){
                System.out.print(rst.get(i).name);
            }else{
                System.out.print(rst.get(i).name + "--->");
            }
        }
    }

    private static int getValueOfPoints(Point p1, Point p2){
        for (Edge edge : allEdges) {
            if((edge.points[0] == p1 && edge.points[1] == p2) || (edge.points[1] == p1 && edge.points[0] == p2)){
                return edge.value;
            }
        }
        return 0;
    }

    private static Point getMinPoint(Point p1, Point[] ps){
        int[] values = new int[ps.length];
        for (int i = 0; i < ps.length; i++) {
            if(ps[i].selected == 0){
                values[i] = getValueOfPoints(p1, ps[i]);
            }else{
                values[i] = 99999;
            }
        }
        int min = values[0];
        int index = 0;
        for (int i = 0; i < values.length; i++) {
            if(values[i] <= min){
                min = values[i];
                index = i;
            }
        }
        return ps[index];
    }
    
}
```
