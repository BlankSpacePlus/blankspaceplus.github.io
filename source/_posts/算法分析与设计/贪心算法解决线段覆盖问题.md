---
title: 贪心算法解决线段覆盖问题
date: 2021-02-17 21:48:04
summary: 本文基于贪心算法解决线段覆盖问题（洛谷P1803题），用C++编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 题目背景

快 noip 了，yyy 很紧张！

# 题目描述

现在各大 oj 上有 $n$ 个比赛，每个比赛的开始、结束的时间点是知道的。

yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。

所以，他想知道他最多能参加几个比赛。

由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 $2$ 个及以上的比赛。

# 输入格式

第一行是一个整数 $n$  ，接下来 $n$ 行每行是 $2$ 个整数 $a_{i},b_{i}$ ( $a_{i}<b_{i}$ )，表示比赛开始、结束的时间。

# 输出格式

一个整数最多参加的比赛数目。

# 样例 #1

## 样例输入 #1

```
3
0 2
2 4
1 3
```

## 样例输出 #1

```
2
```

# 提示

对于 $20\%$ 的数据， $n \le 10$。

对于 $50\%$ 的数据， $n \le 10^3$。

对于 $70\%$ 的数据， $n \le 10^{5}$。

对于 $100\%$ 的数据， $1\le n \le 10^{6}$ ， $0 \le a_{i} < b_{i} \le 10^6$。


# 算法分析

这题是一个线段覆盖问题，但并不是很复杂，也是贪心思想。

想要尽可能放线段，不能重合（可以正好相交），那就可以每一次只关注右端点，尽可能地选择剩余未选的线段中右端点最左且左端点不越过已覆盖区域最右端的一条，如此反复，即为贪心。

贪心嘛，往往与sort绑定，但左右端点是相关的，所谓关联数组，那不如建一个结构体数组然后自定义排序。

所以我们建一个结构体，含有一个左端点一个右端点表示所谓的时间整数（不会爆int），然后将结构体依据右端点排序。

按上述思路扫一遍结构体数组，计数，即可。

# C++实现代码

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

struct oj {
    int begin, end;
};

bool compare(oj a, oj b) {
    return a.end > b.end ? 0 : 1;
}

int main() {
    int n, result = 0, end;
    cin >> n;
    oj ojs[n];
    for (int i = 0; i < n; i++) {
        cin >> ojs[i].begin >> ojs[i].end;
    }
    sort(ojs, ojs+n, compare);
    end = ojs[0].end;
    result++;
    for (int i = 1; i < n;) {
        if (ojs[i].begin >= end) {
            end = ojs[i].end;
            result++;
            i++;
        }
        while (ojs[i].begin < end) {
            i++;
        }
    }
    cout << result << endl;
    return 0;
}
```

# 提交代码

[洛谷 P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
