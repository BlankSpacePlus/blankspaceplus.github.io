---
title: 减治算法解决寻找假币问题
date: 2019-10-06 20:15:56
summary: 本文基于减治算法解决寻找假币问题，用Python编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

问题描述：给出27枚硬币，它们的各种外观完全相同，但有一枚硬币稍重一点，是假币，我们只有一杆秤，试找到一种便捷的方法找出假币。

简单直接的思路是：直接从头到尾扫描遍历一趟，找出最大的即可。算法复杂度是$O(N)$，不符合我们这一问题“尽可能少比较次数”的宗旨。

可以优化上述思路。
容易想到二分查找，进而用将硬币分为2堆+1个，“折半”比较，找出那个特殊的假硬币。

还可以继续优化。
我们可以随机等分成三份，拿出两组比较，划分的对称性更强，查找也更快。
比如9枚硬币，二分最坏的情况是3次查找；三分最坏的结果是2次查找。
又比如本例的27枚硬币，二分最坏的情况是4次查找，三分的最坏结果是3次查找。
毕竟还是节省了比较次数，也很不错了。

归纳如下：
$3^n$枚硬币，最坏情况是需要n+1次比较得出结果。

本例可以运用条件分析后的分治思想很好地递归求解。

下面是Python描述的代码实现（面向过程化写法）：

```python
def compare(groupA, groupB):
    if sum(groupA) > sum(groupB):
        result = 'left'
    elif sum(groupB) > sum(groupA):
        result = 'right'
    else:
        result = 'equal'
    return result


def splitCoins(coinsList):
    length = len(coinsList)
    group1 = coinsList[0:length//3]
    group2 = coinsList[length//3:length//3*2]
    group3 = coinsList[length//3*2:length]
    return group1, group2, group3


def findFakeGroup(group1, group2, group3):
    resultLand2 = compare(group1, group2)
    if resultLand2 == 'left':
        fakeGroup = group1
    elif resultLand2 == 'right':
        fakeGroup = group2
    elif resultLand2 == 'equal':
        fakeGroup = group3
    return fakeGroup


def coinComparision(coinsList):
    counter = 0
    currList = coinsList
    while len(currList) > 1:
        group1, group2, group3 = splitCoins(currList)
        currList = findFakeGroup(group1, group2, group3)
        counter += 1
    fake =currList[0]
    print('The fake coin is coin', coinsList.index(fake)+1, 'in the original list')
    print('Number of weightings:', counter)
```

测试数据：
```python
testList = [10, 10, 10, 10, 10, 10, 11, 10, 10,
            10, 10, 10, 10, 10, 10, 10, 10, 10,
            10, 10, 10, 10, 10, 10, 10, 10, 10]
coinComparision(testList)
```

运行结果：

```python
The fake coin is coin 7 in the original list
Number of weightings: 3
```

思维拓展：
我们如果能够将本例与三进制结合起来会有新的发现：可以用三进制对三分的分治集合进行编号，$0 \sim 3^n-1$。本例中27枚硬币，n=4，第一枚硬币0000、最后一枚硬币2222。每次称量我们都能从从第一位开始逐步确定一位三进制数，最后将结果的三进制转化为十进制，再+1就是结果了。;)
