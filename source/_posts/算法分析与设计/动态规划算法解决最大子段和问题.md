---
title: 动态规划算法解决最大子段和问题
date: 2020-03-12 17:01:25
summary: 本文基于动态规划算法求解最大子段和问题（洛谷P1115题），用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。

# 输入格式

第一行是一个整数，表示序列的长度 $n$。

第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。

# 输出格式

输出一行一个整数表示答案。

# 样例 #1

# 样例输入 #1

```
7
2 -4 3 -1 2 -4 3
```

# 样例输出 #1

```
4
```

# 提示

## 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

# 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

# 算法分析

尽管可以用分治算法求解，但使用动态规划算法求解更优。

动态规划的状态转移方程：$f[i]=max(f[i-1]+n[i], n[i])$。

但 $f[i]$ 未必是答案，这里涉及负数的问题：$n[i]$ 为负数，则 $f[i] < f[i-1]$。所以还需要比较 $f[i]$ 和 $max$ 的大小。

拓展：[贪心算法题解分析](https://www.luogu.com.cn/blog/RobertLYY/solution-p1115)。

# Java实现代码

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(reader.readLine()), max;
        if (num == 0) {
            reader.close();
            System.out.println(0);
            return;
        }
        String[] nums = reader.readLine().split("\\s+");
        reader.close();
        int[] result = new int[num+1];
        result[1] = max = Integer.parseInt(nums[0]);
        for (int i = 2; i <= num; i++) {
            int tempNum = Integer.parseInt(nums[i-1]);
            result[i] = Math.max(result[i-1]+tempNum, tempNum);
            max = Math.max(result[i], max);
        }
        System.out.println(max);
    }
}
```

# 提交代码

[洛谷 P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
