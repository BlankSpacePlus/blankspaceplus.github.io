---
title: 贪心算法解决部分背包问题
date: 2023-01-14 11:38:28
summary: 本文基于贪心算法求解部分背包问题（洛谷P2240题），用C++编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 题目描述

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？

# 输入格式

第一行两个整数 $N,T$。

接下来 $N$ 行，每行两个整数 $m_i,v_i$。

# 输出格式

一个实数表示答案，输出两位小数

# 样例 #1

## 样例输入 #1

```
4 50
10 60
20 100
30 120
15 45
```

## 样例输出 #1

```
240.00
```

# 算法分析

本题是属于背包问题。题意关键句是“**所有金币都可以随意分割，分割完的金币重量价值比不变**”，这意味着这是一个**部分背包问题**，只要按照性价比最高的取一定得到的价值最大，可以用
**贪心算法**解决，不必采用**动态规划算法**。

贪心往往与排序相关。取的是性价比最高的，性价比就是这堆金币的价值除以重量。因此，只要把所有的金币堆按性价比降序排列，遍历，应拿尽拿，直至拿满背包。

# C++实现代码

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

struct Coin {
    double m, v;
};

bool cmp (Coin a, Coin b) {
    return a.v/a.m > b.v/b.m;
}

Coin coins[101];

int main() {
    int n, t;
    cin >> n >> t;
    for (int i = 0; i < n; i++) {
        cin >> coins[i].m >> coins[i].v;
    }
    sort(coins, coins+n, cmp);
    double result = 0;
    for (int i = 0; i < n && t > 1e-6; i++) {
        result += (min((double)t, coins[i].m)*(coins[i].v/coins[i].m));
        t -= min((double)t, coins[i].m);
    }
    printf("%.2f", result);
    return 0;
}
```

# 提交代码

[洛谷 P2240 【深基12.例1】部分背包问题](https://www.luogu.com.cn/problem/P2240)
