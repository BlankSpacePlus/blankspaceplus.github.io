---
title: 分治算法解决树的遍历问题
date: 2023-01-14 19:44:33
summary: 本文基于分治算法解决树的各种遍历问题（LeetCode94+102+144+145题），用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 树的遍历

树的遍历分为四种：前序遍历、中序遍历、后序遍历、层序遍历。

前三种遍历方式的实现都用到了分治算法，且都有递归实现和非递归实现两种。

结构定义：
```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

给你二叉树的根节点 root ，返回它节点值的 前序/中序/后序/层序 遍历。

![](../../images/算法分析与设计/分治算法解决树的遍历问题/1.jpg)

# 前序遍历

非递归实现：借助栈结构，出栈节点的右儿子节点先入栈，左儿子节点后入栈。

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        if (root != null) {
            stack.add(root);
            while (!stack.isEmpty()) {
                TreeNode tempNode = stack.pop();
                result.add(tempNode.val);
                if (tempNode.right != null) {
                    stack.add(0, tempNode.right);
                }
                if (tempNode.left != null) {
                    stack.add(0, tempNode.left);
                }
            }
        }
        return result;
    }
}
```

代码提交：[LeetCode144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

# 中序遍历

非递归实现：借助栈结构，先将出栈节点的右儿子节点入栈，再考虑出栈节点的左儿子节点。如果出栈节点存在左儿子节点，则出栈节点和其左儿子节点入栈；如果其不存在左儿子节点，则输出当前出栈节点。

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        if (root != null) {
            stack.add(root);
            while (!stack.isEmpty()) {
                TreeNode tempNode = stack.pop();
                if (tempNode.right != null) {
                    stack.add(0, tempNode.right);
                    tempNode.right = null;
                }
                if (tempNode.left == null) {
                    result.add(tempNode.val);
                } else {
                    stack.add(0, tempNode);
                    stack.add(0, tempNode.left);
                    tempNode.left = null;
                }
            }
        }
        return result;
    }
}
```

代码提交：[LeetCode 94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

# 后序遍历

非递归实现：借助栈结构，同时考虑出栈节点是否存在左右儿子节点。如果左右儿子节点都不存在，则输出当前节点；如果有存在，则先右后左入栈。

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        if (root != null) {
            stack.add(root);
            while (!stack.isEmpty()) {
                TreeNode tempNode = stack.pop();
                boolean flag = true;
                if (tempNode.right != null) {
                    stack.add(0, tempNode);
                    stack.add(0, tempNode.right);
                    tempNode.right = null;
                    flag = false;
                }
                if (tempNode.left != null) {
                    if (flag) {
                        stack.add(0, tempNode);
                    }
                    stack.add(0, tempNode.left);
                    tempNode.left = null;
                    flag = false;
                }
                if (flag) {
                    result.add(tempNode.val);
                }
            }
        }
        return result;
    }
}
```

代码提交：[LeetCode 145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

# 层序遍历

层序遍历是BFS，与前面三个DFS不同，要借助队列结构而不是栈结构，具体区别参考：[DFS与BFS的区别](https://blankspace.blog.csdn.net/article/details/115131649)。

每一次处理完一层的节点。层内每个节点先左儿子后右儿子追加进入队列。

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if (root != null) {
            queue.add(root);
            while (!queue.isEmpty()) {
                List<Integer> tempList = new LinkedList<>();
                int size = queue.size();
                for (int i = 0; i < size; i++) {
                    TreeNode tempNode = queue.poll();
                    tempList.add(tempNode.val);
                    if (tempNode.left != null) {
                        queue.add(tempNode.left);
                    }
                    if (tempNode.right != null) {
                        queue.add(tempNode.right);
                    }
                }
                result.add(tempList);
            }
        }
        return result;
    }
}
```

代码提交：[LeetCode102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
