---
title: 分治算法解决快速排序问题
date: 2020-02-18 16:05:18
summary: 本文基于分治算法解决快速排序问题，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 快速排序简介

快速排序(QuickSort)是对冒泡排序(BubbleSort)的一种改进，由C. A. R. Hoare在1960年提出。

快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快速排序的效率很高，对随机序列比较有效，平均时间复杂度为$O(N\log{N})$，但也可能遇到$O(N^2)$的糟糕情况。如果加以优化，$O(N^2)$的情况基本不可能出现。

快速排序的实现是面试常考的知识，是必须掌握的重点知识。

# 快速排序的流程

快速排序算法通过多次比较和交换来实现排序，其排序流程如下：
1. 首先设定一个分界值，通过该分界值将数组分成左右两部分。
2. 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

# 快速排序的动图演示

![](../../images/算法分析与设计/分治算法解决快速排序问题/1.gif)

# 快速排序的优化策略

其实快排是一个天才般的算法，对其优化主要从两个角度展开：
1. 试图更合理地选取的中轴，尽量使得划分均匀一些。
2. 试图在快排效率不好的时候更换算法或与其他算法组合，使之更高效。
下面给一些说明。

## 二分法

运用二分思想，每次取划分出的区间的中值作为新的一次划分的中轴。
一般来说，快排对随机序列很好使，所以说我们可以认为，平均来讲去取中值更可能划分的比较均匀。

## 随机化

既然快排本身面对的就是随机序列，其实我们可以认为随机化地取枢纽值会比任意取好一些，至少比直接取一侧的值好一些。
随机化本身就可能是一种算法优化的策略，至少也是一种参考指标。

## 结合其他排序算法互补

快速排序并非没有缺点，时间复杂度在最坏情况下会退化到$O(N^2)$，划分到小区间时效率甚至可能不如简单的排序算法。

TimSort就是一个非常有趣的例子，将快速排序与其他排序算法相结合，实现了更高的排序效率。

# 快速排序的编程实现

## Java编程实现

笔者的[这篇文章](https://blog.csdn.net/weixin_43896318/article/details/98208593)给出了基于Java的实现。

## C++编程实现

这个版本是利用了二分的思想对算法进行了优化，使得原先的算法性能得到了一定程度的提高。

```cpp
#include<iostream>
using namespace std;
int num, array[100001];

/**
 * 应用二分思想
 * @param left 左索引
 * @param right 右索引
 */
void quickSort(int left, int right) {
    // 中间数
    int mid = array[(left+right)/2];
    int i = left, j = right;
    do {
        while (array[i] < mid) {
            // 查找左半部分比中间数大的数
            i++;
        }
        while (array[j] > mid) {
            // 查找右半部分比中间数小的数
            j--;
        }
        if (i <= j) {
            // 交换
            swap(array[i], array[j]);
            i++;
            j--;
        }
    } while (i <= j);
    if (left < j) {
        // 递归搜索左半部分
        quickSort(left, j);
    }
    if (i < right) {
        // 递归搜索右半部分
        quickSort(i, right);
    }
}

int main() {
    cin >> num;
    for (int i = 1; i <= num; i++) {
        cin >> array[i];
    }
    quickSort(1, num);
    for (int i = 1; i <= num; i++) {
        cout << array[i] << " ";
    }
}
```

# 比较快速排序与二路归并排序

[这篇文章](https://blog.csdn.net/weixin_43896318/article/details/102472394)对二者的基本情况进行了比较详细的阐述，下面对二者的算法思想进行对比分析。

归并排序和快速排序都使用了[分治思想](https://blog.csdn.net/weixin_43896318/article/details/102770051)，可以通过递归很好的完成排序工作。二者的不同在于：**快速排序的核心算法是划分，二路归并排序的核心算法是合并**。

大家有没有想过这样一件事：快速排序和二路归并排序分别是在什么时候完成的排序？
- 快速排序在划分的时候，将大的放到轴右侧、小的换到轴的左侧，在这个划分的时候完成排序，它的“分治”，“分”是核心，所以“划分”是核心算法，等到分无可分就完成了子区间的排序，子区间都排完，整体区间就完成了排序。
- 二路归并排序的“分”只是为了二分地分解大区间为小的子区间，在“合”的时候完成排序，它的“分治”，“并”是核心，所以“合并”是核心算法，等到分无可分就可以逐步合并区间了，最终就完成了整体区间的排序。

**总结**：
- 快速排序在划分的时候完成排序，重点在“分”；归并排序在“并”的时候完成排序，重点在“并”。
- 快速排序属于交换排序，与归并排序有很大的不同，快排的“分”也是通过交换完成的。
