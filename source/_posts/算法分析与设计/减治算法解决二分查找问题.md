---
title: 减治算法解决二分查找问题
date: 2019-10-07 11:16:13
summary: 本文基于减治算法解决二分查找问题（洛谷P2249题），用C++编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 二分查找的基础理论

## 二分查找是一种减治算法

通常称二分查找为分治算法，其实更严谨的解释是减治算法。这是因为二分查找 **每次都舍弃一半，从留下的一半中寻找目标** ；而分治法把一个大问题分成两个或多个小问题，递归地求这些小问题的解，最后再把它们合并起来，并且要仔细考虑合并时产生的新的情况。

## 二分查找的前提是线性有序的随机访问序列

二分查找针对的是线性结构，是一种线性查找方法。由于二分查找需要丢弃另一半，丢弃的一半必须是确认无效的，因此序列必须是有序的。

二分查找并不适用于所有的线性序列。二分查找需要大量地借助下标索引随机访问线性序列的元素，这是链表等结构所不支持的。

## 二分查找的执行效率

由于二分查找每次都丢弃一半的区间，所以能逐步的简化问题求解，特别是在数据量庞大的时候会有很好的效率。

二分查找的时间复杂度是$O(\log{n})$，空间复杂度是$O(1)$。

事实上，为了维护有序序列，整体的时间复杂度肯定不止$O(\log{n})$，只是这里我们只考虑二分查找本身。

## 二分查找的平均查找长度

例题：对于长度为 $9$ 的顺序存储的有序表 ${1, 2, 3, 4, 5, 6, 7, 8, 9}$ ，若采用二分查找，求平均查找长度。

值得注意的是，每次减治缩范围后新的 $left$ 或 $right$ 不等于 $mid$，下面简单分析一下：
- 第一步，$left=1, right=9, mid=(1+9)/2=5$
  - 第二步，$left=1, right=5-1=4, mid=(1+4)/2=2$
    - 第三步，$left=1, right=2-1=1, mid=(1+1)/2=1$
    - 第三步，$left=2+1=3, right=4, mid=(3+4)/2=3$
      - 第四步，$left=3+1=4, right=4, mid=(4+4)/2=4$
  - 第二步，$left=5+1=6, right=9, mid=(6+9)/2=7$
    - 第三步，$left=6, right=7-1=6, mid=(6+6)/2=6$
    - 第三步，$left=7+1=8, right=9, mid=(8+9)/2=8$
      - 第四步，$left=8+1=9, right=9, mid=(9+9)/2=9$

搜索树的示意图如下所示：
![](../../images/算法分析与设计/减治算法解决二分查找问题/1.jpg)

## 推广二分查找而不是三分查找的理由

为什么一定是二分查找，而不是三分查找呢？原因有二：
1. 性能问题。二分查找最坏情况$\log_{2}{n}$，三分查找最坏情况$2\log_{3}{n}$，经过求导运算证实，二分查找性能高。
2. 简洁适配问题。计算机是二进制的，二分查找的思想带来编码的简化和思维的清晰化。

# 二分查找的实现细节

## 二分查找的开闭区间的选取

通常，编程语言的区间设置都是[左闭右开]((https://blog.csdn.net/weixin_43896318/article/details/99618264))的，因此左取右不取。

## 二分查找的中值的正确选取

通常来讲，`mid = (left+right)/2`即可，但这样写有两处可优化：
1. 如果left和right都不溢出，但left+right溢出，就会很麻烦，因此可以改写为`mid = left+(right-left)/2`。
2. 位移运算符可以简化除法运算，因此可以改写为`mid = left+((right-left)>>>1)`。

当然，这两处都是可以不优化的，原因在于：
1. 虽然存在潜在的溢出问题，但二分查找毕竟是实实在在发生在线性数据结构上的，内存中很难存储简单的${10}^{9}$级线性数据结构，不现实。
2. 仅考虑二分查找问题，位运算能带来的优化是有限的，反而可读性降低。关于位运算，可看[>>>、>>、<< 辨析](https://blog.csdn.net/weixin_43896318/article/details/104367077)。

## 二分查找的递归与非递归

二分查找通常用非递归实现，但也完全可以递归实现。

# 二分查找的编程实现

## Python实现

```python
def binarySearch(l, value):
    low, high = 0, len(l)-1
    while low < high:
        # 这里建议规范一下
        mid = low + (high - low)//2
        if l[mid] < value:
            # 向上缩小区间
            low = mid+1
        elif value < l[mid]:
            # 向下缩小区间
            high = mid-1
        else:
            # 找到了
            return mid
    # 没找到
    return -1
```

## Java实现

```java
public static int binarySearch(int[] array, int fromIndex, int toIndex, int key) {
    int low = fromIndex;
    int high = toIndex - 1;
    while(low <= high) {
        int mid = low + (high - low >>> 1);
        int midValue = array[mid];
        if (midValue < key) {
            low = mid + 1;
        } else {
            if (midValue <= key) {
                return mid;
            }
            high = mid - 1;
        }
    }
    return -(low + 1);
}
```

## Java广义实现

借助泛型，实现普适的二分查找。

```java
public class BinarySearch {

    private static final int NOT_FOUND = -1;

    public static <T extends Comparable<? super T>> int binarySearch(T[] array, T t) {
        int low = 0, high = array.length - 1;
        while(low <= high) {
            int mid = low + high >>> 1;
            if(array[mid].compareTo(t) < 0) {
                low = mid + 1;
            } else if(array[mid].compareTo(t) > 0) {
                high = mid - 1;
            } else {
                return mid;
            }
        }
        return NOT_FOUND;
    }
    
}
```

# 洛谷P2249查找

## 题目描述

输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。

## 输入格式

第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。

第二行 $n$ 个整数，表示这些待查询的数字。

第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。

## 输出格式

输出一行，$m$ 个整数，以空格隔开，表示答案。

## 样例 #1

### 样例输入 #1

```
11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6
```

### 样例输出 #1

```
1 2 -1
```

## 提示

数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$

本题输入输出量较大，请使用较快的 IO 方式。

## C++编程实现

```cpp
#include <iostream>

using namespace std;

int nums[1000001];

int main() {
    int n, m, query;
    cin >> n >> m;
    // 因为结果计算的下标是从1开始的
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
    }
    for (int i = 0; i < m; i++) {
        cin >> query;
        int result = lower_bound(nums+1, nums+n+1, query)-nums;
        cout << ((query == nums[result]) ? result : -1) << " ";
    }
    return 0;
}
```

## 提交代码

[洛谷 P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)
