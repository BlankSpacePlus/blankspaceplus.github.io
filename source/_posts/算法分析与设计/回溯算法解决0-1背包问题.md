---
title: 回溯算法解决0-1背包问题
date: 2021-02-15 21:24:48
summary: 本文基于回溯算法解决0-1背包问题，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 问题描述

给定$n$种物品和一背包。物品$i$的重量是$w_{i}>0$，其价值为$v_{i}>0$，背包的容量为$c$。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？

# 编程任务

利用回溯法试设计一个算法求出0-1背包问题的解，也就是求出一个解向量$x_{i}$（$x_{i}=0$或$x_{i}=1$，$x_{i}=0$表示物体$i$不放入背包，$x_{i}=1$表示把物体i放入背包），使得尽量多的价值装入背包。

# 数据输入

由文件**input.txt**提供输入数据$n$，$c$，及每个物品的重量$w[]$和价值$v[]$。

# 结果输出

程序运行结束时，将最优解输出到文件**output.txt**中。

# 自定义输入文件示例

```txt
4
5
2 1 3 2
12 10 20 15
```

# 编程实现

```java
import java.io.*;
import java.util.Arrays;
import java.util.Comparator;

public class Solution2 {

    // 物品数目
    private static int num;

    // 背包最大承重
    private static int maxWeight;

    // n件物品的重量
    private static int[] weight;

    // n件物品的价值
    private static int[] value;

    // 背包中当前重量
    private static int currentWeight = 0;

    // 背包中当前价值
    private static int currentValue = 0;

    // 当前最优价值
    private static int bestValue = 0;

    // 物品
    private static Item[] items;

    // 记录当前规则中物品放了与否
    private static int[] tempX;

    // 记录最优规则的物品放了与否
    private static int[] bestX;

    private static class Item {
        // 物品编号
        int id;
        // 该物品单位质量的价格
        double averagePrice;
        Item(int id,double averagePrice){
            this.id=id;
            this.averagePrice=averagePrice;
        }
    }

    // 回溯算法
    private static void backtrack(int t) {
        // 超出层数，当前背包中的价值就是最优值
        if(t > num) {
            bestValue = currentValue;
            for(int j = 0; j <= num; j++) {
                bestX[j] = tempX[j];
            }
            return;
        }
        // 可以放入下一个物品
        if(currentWeight + weight[items[t].id] <= maxWeight) {
            tempX[items[t].id] = 1;
            currentWeight += weight[items[t].id];
            currentValue += value[items[t].id];
            backtrack(t+1);
            currentWeight -= weight[items[t].id];
            currentValue -= value[items[t].id];
        }
        // 进入右子树
        if(bound(t+1) > bestValue) {
            tempX[items[t].id] = 0;
            backtrack(t+1);
        }
    }

    // 进入右子树时计算上界
    private static double bound(int t){
        double topBound = currentValue;//上界
        double leftWeight = maxWeight - currentWeight;
        // 将整件物品放入
        while(t <= num && leftWeight >= weight[items[t].id]) {
            leftWeight -= weight[items[t].id];
            topBound += value[items[t].id];
            t++;
        }
        // 不能整件放入的切开放
        if(t <= num) {
            topBound += leftWeight * items[t].averagePrice;
        }
        return topBound;
    }

    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("src/bt/input2.txt"));
             BufferedWriter writer = new BufferedWriter(new FileWriter("src/bt/output2.txt"))) {
            num = Integer.parseInt(reader.readLine());
            maxWeight = Integer.parseInt(reader.readLine());
            String[] weights = reader.readLine().split("\\s+"), values = reader.readLine().split("\\s+");
            weight = new int[num+1];
            value = new int[num+1];
            items = new Item[num+1];
            tempX = new int[num+1];
            bestX = new int[num+1];
            for (int i = 1; i <= num; i++) {
                weight[i] = Integer.parseInt(weights[i-1]);
                value[i] = Integer.parseInt(values[i-1]);
                items[i] = new Item(i, value[i]/weight[i]);
            }
            items[0] = new Item(0,0);
            // 按照每个物品的单位质量的价格降序排列
            Arrays.sort(items, Comparator.comparing(e -> e.averagePrice));
            backtrack(1);
            StringBuilder builder = new StringBuilder();
            for (int i = 1; i <= num; i++) {
                builder.append(bestX[i]).append(' ');
            }
            String result = builder.toString().trim() + "\n";
            System.out.print(result);
            System.out.println(bestValue);
            writer.write(result);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

# 输出结果

```txt
1 1 0 1
```
