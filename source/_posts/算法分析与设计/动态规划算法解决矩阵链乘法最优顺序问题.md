---
title: 动态规划算法解决矩阵链乘法最优顺序问题
date: 2020-02-25 22:05:54
summary: 本文基于动态规划解决矩阵链乘法最优顺序问题，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 矩阵链乘法

矩阵连乘，选择不同的乘法顺序，效率可能千差万别。

高效的实现算法应该用动态规划来设计，具体的讲解可以看[这里](https://www.cnblogs.com/fsmly/p/10228767.html)。

# Java编程实现

```java
public class Main {

    private static final long INFINITY = Long.MAX_VALUE;

    /**
     * 计算矩阵乘法的最优次序
     * c包含n个矩阵中每个矩阵的列数，c[0]是矩阵1中的行数
     * 最小乘法次数保留在m[1][n]中
     * m和lastChange从1开始索引(而不是0)，主对角线下方的条目没有意义且未初始化
     */
    private static void optMatrix(int[] c, long[][] m, int[][] lastChange) {
        int n = c.length - 1;
        for (int left = 1; left <= n; left++) {
            m[left][left] = 0;
        }
        // k = (right - left)
        for (int k = 1; k < n; k++) {
            for(int left = 1; left <= n-k; left++) {
                int right = left + k;
                m[left][right] = INFINITY;
                for (int i = left; i < right; i++) {
                    long thisCost = m[left][i] + m[i+1][right] + c[left-1] * c[i] * c[right];
                    if (thisCost < m[left][right]) {
                        m[left][right] = thisCost;
                        lastChange[left][right] = i;
                    }
                }
            }
        }
    }

    public static void main(String [] args) {
        int[] c = { 50, 10, 40, 30, 5 };
        long[][] m = new long [5][5];
        int[][] lastChange = new int [5][5];
        optMatrix(c, m, lastChange);
        for (int i = 1; i <= 4; i++) {
            for (int j = 1; j <= 4; j++) {
                System.out.print(m[i][j] + "\t");
            }
            System.out.println();
        }
        for (int i = 1; i <= 4; i++) {
            for (int j = 1; j <= 4; j++) {
                System.out.print(lastChange[i][j] + "\t");
            }
            System.out.println();
        }
    }

}
```
