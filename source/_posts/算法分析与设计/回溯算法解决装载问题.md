---
title: 回溯算法解决装载问题
date: 2021-02-15 21:24:37
summary: 本文基于回溯算法解决装载问题，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 问题描述

有一批共$n$个集装箱要装上$2$艘载重量分别为$c_{1}$和$c_{2}$的轮船，其中集装箱$i$的重量为$w_{i}$，且$\sum{w_{i}≤c_{1}+c_{2}}$，要求确定是否有一个合理的装载方案可将这$n$个集装箱装上这$2$艘轮船。如果有，请给出该方案。

# 编程任务

利用回溯法试设计一个算法求出该装载问题的解。

# 数据输入

由文件**input.txt**提供输入数据。文件的第$1$行中有$2$个正整数$n$及$c$，表示有$n$个集装箱，第一艘船的载重量为$c$。接下来的一行为每个集装箱的重量。

# 结果输出

程序运行结束时，将计算出的最优解输出到文件**output.txt**中，如果某集装箱被装入船上，则对应的解为$1$，如果不能装入则为$0$。

# 自定义输入文件示例

```txt
3 30
16 15 15
```

# 编程实现

```java
import java.io.*;

public class Solution1 {

    // 集装箱数
    private static int num;

    // 集装箱重量数组
    private static int[] weights;

    // 第一艘轮船的载重量
    private static int costs;

    // 当前载重量
    private static int tempWeight;

    // 当前最优载重量
    private static int bestWeight;

    // 剩余集装箱重量
    private static int left;

    // 当前解
    private static int[] tempX;

    // 当前最优解
    private static int[] bestX;

    private static void backtrace(int i) {
        // 到达叶子结点  i此时的值=叶节点+1
        if (i > num-1 && tempWeight > bestWeight) {
            for (int j = 0; j < num; j++) {
                bestX[j] = tempX[j];
            }
            bestWeight = tempWeight;
            return;
        }
        left -= weights[i];
        // 递归搜索 左子树
        if (tempWeight + weights[i] <= costs) {
            tempX[i] = 1;
            tempWeight += weights[i];
            backtrace(i+1);
            // 回溯
            tempWeight -= weights[i];
        }
        // 递归搜索 右子树
        if (tempWeight + left > bestWeight) {
            tempX[i] = 0;
            backtrace(i+1);
        }
        left += weights[i];
    }

    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("src/bt/input1.txt"));
             BufferedWriter writer = new BufferedWriter(new FileWriter("src/bt/output1.txt"))) {
            String[] line1 = reader.readLine().split("\\s+");
            num = Integer.parseInt(line1[0]);
            costs = Integer.parseInt(line1[1]);
            weights = new int[num];
            tempX = new int[num];
            bestX = new int[num];
            tempWeight = bestWeight = 0;
            String[] nums = reader.readLine().split("\\s+");
            for (int i = 0; i < num; i++) {
                weights[i] = Integer.parseInt(nums[i]);
                left += weights[i];
            }
            backtrace(0);
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < num; i++) {
                builder.append(bestX[i]).append(' ');
            }
            String result = builder.toString().trim();
            System.out.println("最优解：" + result);
            System.out.println("最优值：" + bestWeight);
            writer.write(result);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

# 输出结果

```txt
0 1 1
```
