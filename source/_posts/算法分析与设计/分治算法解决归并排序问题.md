---
title: 分治算法解决归并排序问题
date: 2021-02-15 21:23:48
summary: 本文基于分治算法解决归并排序问题，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

#  问题描述

目前的网上拍卖系统会显示很多待拍卖的物品，通常这些系统具有按照某个关键字对打出的广告进行排序列出的功能，并且能够按照用户输入的某个关键字进行过虑，找到某些特定的物品。

# 编程任务

定义一个Advertisement类，该类中至少包含该物品的数量，名称，联系人e-mail，最好有开拍时间及关闭时间，根据用户输入的关键字比如名称，mail，时间等，利用非递归的归并排序对所有的广告进行排序，并列出所有排好序的广告。

# 数据输入

由文件**input.txt**提供输入的所有广告信息。程序中由用户输入要排序的关键字。

# 结果输出

程序运行结束时，排好序的广告输出到文件**output.txt**中，并为每个广告添加序号。

# 自定义输入文件示例

```txt
Coat
3
a@mail.com
20160327121233
20190403184029
Skirt
5
b@mail.com
20170127214334
20190403142059
Cap
7
c@mail.com
20180830142608
20190512165752
Bag
12
a@mail.com
20180830142607
20190512165752
Title
```

# 编程实现

```java
import java.io.*;

public class Solution3 {

    private static int num;

    private static Advertisement[] advertisements;

    private static class Advertisement implements Comparable<Advertisement> {
        String name; // 名称
        Integer num; // 数量
        String email; // 电子邮件
        String startTime; // 开始时间
        String endTime; // 结束时间
        Advertisement(String name, int num, String email, String startTime, String endTime) {
            this.name = name;
            this.num = num;
            this.email = email;
            this.startTime = startTime;
            this.endTime = endTime;
        }
        @Override
        public int compareTo(Advertisement obj) {
            int nameResult = this.name.compareTo(obj.name);
            int numResult = this.num.compareTo(obj.num);
            int emailResult = this.email.compareTo(obj.email);
            int startTimeResult = this.startTime.compareTo(this.endTime);
            int endTimeResult = this.endTime.compareTo(obj.endTime);
            return (nameResult != 0 ? nameResult : numResult != 0 ? numResult : emailResult != 0 ? emailResult :
                    startTimeResult != 0 ? startTimeResult : endTimeResult);
        }
    }

    private static void merge(int first1, int last1, int last2) {
        //定义辅助数组temp
        Advertisement[] temp = new Advertisement[num];
        //设置两个待合并的起止区间
        int i = first1, j = last1+1, index = first1;
        //依次取两序列中小者放入temp
        while (i <= last1 && j <= last2) {
            if (advertisements[i].compareTo(advertisements[j]) <= 0) {
                temp[index++] = advertisements[i++];
            } else {
                temp[index++] = advertisements[j++];
            }
        }
        //对第一个子序列进行收尾处理
        while (i <= last1) {
            temp[index++] = advertisements[i++];
        }
        //对第二个子序列进行收尾处理
        while (j <= last2) {
            temp[index++] = advertisements[j++];
        }
        //将合并后的结果传回数组record
        for (index = first1; index <= last2; index++) {
            advertisements[index] = temp[index];
        }
    }

    private static void mergePass(int h) {
        int i = 0;
        //有两个长度为h的子序列
        while (i <= num - 2*h + 1) {
            merge(i, i+h-1, i+2*h-1);
            i += 2*h;
        }
        //子序列有一个长度小于h
        if (i < num-h+1) {
            merge(i, i+h-1, num -1);
        }
    }

    private static void mergeSort() {
        //初始时子序列长度为1
        int h = 1;
        while (h < num) {
            //一趟排序
            mergePass(h);
            h*=2;
        }
    }

    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("src/dc/input3.txt"));
             BufferedWriter writer = new BufferedWriter(new FileWriter("src/dc/output3.txt"))){
            num = 4;
            advertisements = new Advertisement[num];
            for (int i = 0; i < num; i++) {
                advertisements[i] = new Advertisement(reader.readLine(), Integer.parseInt(reader.readLine()),
                        reader.readLine(), reader.readLine(), reader.readLine());
            }
            mergeSort();
            for (int i = 0; i < num; ) {
                Advertisement obj = advertisements[i];
                writer.write(++i + "\n");
                writer.write("\t" + obj.name + "\n");
                writer.write("\t" + obj.num + "\n");
                writer.write("\t" + obj.email + "\n");
                writer.write("\t" + obj.startTime + "\n");
                writer.write("\t" + obj.endTime + "\n");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

# 输出结果

```txt
1
	Bag
	12
	a@mail.com
	20180830142607
	20190512165752
2
	Cap
	7
	c@mail.com
	20180830142608
	20190512165752
3
	Coat
	3
	a@mail.com
	20160327121233
	20190403184029
4
	Skirt
	5
	b@mail.com
	20170127214334
	20190403142059
```
