---
title: 递归算法与非递归算法
date: 2019-10-06 13:50:26
summary: 本文浅析递归算法与非递归算法。
tags:
- 算法
categories:
- 算法分析与设计
---

斐波那契数列、阶乘、GCD都属于简单的递归可解问题。

下面是斐波那契数列和阶乘的递归实现：

```java
class RecursionException extends RuntimeException {

    public RecursionException() {
        System.out.println("递归异常");
    }

    public RecursionException(String message) {
        System.out.println("递归异常" + message);
    }

}

public class Recursion {

    public static int fibonacci(int n) {
        if (n <= 0) {
            throw new RecursionException("输入值必须大于0");
        } else if (n == 1 || n ==2) {
            return 1;
        } else {
            return fibonacci(n-1) + fibonacci(n-2);
        }
    }

    public static long factorial(int n) {
        if (n < 0) {
            throw new RecursionException("输入值不能小于0");
        } else if (n == 0) {
            return 1;
        } else {
            return n * factorial(n-1);
        }
    }

    public static void main(String[] args) {
        System.out.println(fibonacci(5));
        System.out.println(factorial(5));
    }

}
```

下面是求解最大公约数的递归和非递归实现：

```python
# 非递归
def iGcd(m, n):
    while n > 0:
        m, n = n, m%n
    return m


# 递归
def rGcd(m, n):
    if m % n == 0:
        return n
    else:
        gcd = rGcd(n, m%n)
        return gcd
```

由于**树本身就是递归定义的**，所以树相关算法需要大量用到递归，也可以非递归实现，[二叉树算法](https://blog.csdn.net/weixin_43896318/article/details/101633969)自然也是如此。

[汉诺塔问题](https://blog.csdn.net/weixin_43896318/article/details/102156167)、[归并排序](https://blog.csdn.net/weixin_43896318/article/details/98208593)等问题也是递归求解的经典算法问题。

初学者可能会抵触递归，但其实递归的思考方式非常简单。递归通过自己调用自己，**不断缩减问题规模直至能够简单求解**，一步一步得出结果。

**递归的空间复杂度较高**。比如归并排序，它相比较起其他基本排序方法是很消耗空间的，它用$O(N)$的空间复杂度去交换了比较小的时间复杂度$O(N\log{N})$；再比如阶乘的递归求解，我们计算$factorial(100000)$的时候，系统不会给出任何结果，而是抛出`java.lang.StackOverflowError`的栈溢出异常（错误），方法栈过深，深递归“耗尽”了JVM中方法栈区内存，可见其消耗的存储空间之大。

**递归的时间复杂度较高**。比如斐波那契数列的递归实现，经过数学归纳法证明，其时间复杂度为[$O((\frac{5}{3})^n)$](https://blankspace.blog.csdn.net/article/details/101903721)，相当高，以至于**这种指数级的算法时间复杂度在实际中根本不可接受**。

而且，递归函数实际上是“自己调用自己”，它自己本身就是一个函数（方法），**这种调用是有成本的**，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，还需要进行额外的入栈、出栈操作。

**递归函数往往可以写成非递归形式**，这种转变往往依靠合适的循环迭代和一定的辅助性数据结构（栈、队列等）。实际实现往往需要用非递归代替递归。

读书时看到的一句话：学好递归的方法是多读多看优质的递归代码和多思考多尝试。
共勉！
