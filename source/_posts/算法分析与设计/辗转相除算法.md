---
title: 辗转相除算法
date: 2020-02-06 18:25:33
summary: 本文分享最大公因数的辗转相除法算法，用Java编程实现。
mathjax: true
tags:
- 算法
categories:
- 算法分析与设计
---

# 算法介绍

**辗转相除法**又称**欧几里德算法**，是指用于计算两个正整数$a$，$b$的**最大公因数**的一种算法。

广泛应用于数学和计算机两个方面。

计算公式：`gcd(a, b) = gcd(b, a%b)`。

算法特点：
- 以**除法**为主。
- 两整数**差值较大**时运算**次数较少**。
- 相除**余数为0**时得到结果。
- 是**循环**表示的**递推**式子，也可以**递归**实现。

# 算法证明

设两数为a, b(a>b)，用gcd(a, b)表示a, b的最大公约数，r=a (mod b) 为a除以b的余数，k为a除以b的商，即a÷b=kr。辗转相除法即是要证明gcd(a,b)=gcd(b,r)。

第一步:令c=gcd(a,b)，则设a=mc，b=nc。

第二步:根据前提可知r =a-kb=mc-knc=(m-kn)c。

第三步:根据第二步结果可知c也是r的因数。

第四步:可以断定m-kn与n互质(假设m-kn=xd，n=yd (d>1)，则m=kn+xd=kyd+xd=(ky+x)d，则a=mc=(ky+x)cd，b=nc=ycd，则a与b的一个公约数cd>c，故c非a与b的最大公约数，与前面结论矛盾)，因此c也是b与r的最大公约数。

从而可知gcd(b, r)=c，继而gcd(a, b)=gcd(b, r)。

# 应用实例

求56和24的最大公因数

56%24 = 8

24%8 = 0

结果为8

# 拓展应用

由于**最大公约数和最小公倍数的乘积就是原两个数的积**，所以在根据gcd()求出最大公因数以后，就可以根据两数本身和其最大公因数求出最小公倍数咯！

# BigInteger支持

**java.math.BigInteger** 中有 **gcd()** 方法：`public BigInteger gcd​(BigInteger val)`

# 算法实现

## Java实现

非递归版本：

```java
public static int gcd (int p, int q) {
    if (q == 0) {
        return p;
    } else {
        return gcd (q, p%q);
    }
}
```

递归版本：

```java
public static int gcd (int p, int q) {
    while (q != 0) {
        int temp = p % q;
        p = q;
        q = temp;
    }
    return p;
}
```

long版本：

```java
public static long gcd(long p, long q) {
    while(q != 0) {
        long temp = p % q;
        p = q;
        q = temp;
    }
    return p;
}
```

## C/C++实现

```c
int gcd(int p, int q) {
   if(q == 0) {
       return p;
   } else {
       gcd(q, p%q);
   }
}
```

# 实战演练
[这里](https://blog.csdn.net/weixin_43896318/article/details/104129681)有一个实战例题。
