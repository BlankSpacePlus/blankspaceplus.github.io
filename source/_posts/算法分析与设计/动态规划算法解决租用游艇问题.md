---
title: 动态规划算法解决租用游艇问题
date: 2021-02-15 21:24:27
summary: 本文基于动态规划算法解决找租用游艇问题，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 问题描述

长江游艇俱乐部在长江上设置了$n$个游艇出租站$1,2,…,n$。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站$i$到游艇出租站$j$之间的租金为$r(i,j)$，$1≤i<j≤n$。试设计一个算法，计算出从游艇出租站$1$到游艇出租站$n$所需的最少租金。

# 编程任务

对于给定的游艇出租站i到游艇出租站j之间的租金为$r(i,j)$，$1≤i<j≤n$，编程计算从游艇出租站$1$到游艇出租站$n$所需的最少租金。

# 数据输入

由文件**input.txt**提供输入数据。文件的第$1$行中有一个正整数$n(n<=200)$，表示有$n$个游艇出租站。接下来的$n-1$行是$r(i,j)$，$1≤i<j≤n$。

# 结果输出

程序运行结束时，将计算出的从游艇出租站$1$到游艇出租站$n$所需的最少租金输出到文件**output.txt**中。

# 自定义输入文件示例

```txt
3
5 15
7
```

# 编程实现

```java
import java.io.*;

/**
 * 租用游艇问题
 */
public class Solution2 {

    private static int[][] cost;

    private static final int INF = 0x3f3f3f3f;

    private static int num;

    /**
     * Floyd 求最短路
     * 动态规划思想，适用于有向图，仅能从上游移动到下游
     */
    private static void shortestPath() {
        for (int k = 0; k < num; k++) {
            for (int i = 0; i < k; i++) { // 只从上游到下游，i不必大于等于k
                for (int j = i+1; j < num; j++) { // j大于i即可
                    if (cost[i][k] != INF && cost[k][j] != INF && cost[i][k] + cost[k][j] < cost[i][j]) {
                        cost[i][j] = cost[i][k] + cost[k][j];
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("src/dp/input2.txt"));
             BufferedWriter writer = new BufferedWriter(new FileWriter("src/dp/output2.txt"))){
            num = Integer.parseInt(reader.readLine());
            cost = new int[num][num];
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    cost[i][j] = INF;
                }
            }
            for (int i = 0; i < num-1; i++) {
                String[] nums = reader.readLine().split("\\s+");
                for (int j = i+1; j < num; j++) {
                    cost[i][j] = Integer.parseInt(nums[j-i-1]);
                }
            }
            //求最短路并输出到文件
            shortestPath();
            writer.write(Integer.toString(cost[0][num-1]));
            // 标准输出各顶点之间的最短路径
            for (int i = 0; i < num; i++) {
                StringBuilder result = new StringBuilder();
                for (int j = 0; j < num; j++) {
                    if (cost[i][j] == INF || i > j) {
                        result.append("INF\t");
                    } else {
                        result.append(cost[i][j]).append('\t');
                    }
                }
                System.out.println(result);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

# 输出结果

```txt
12
```
