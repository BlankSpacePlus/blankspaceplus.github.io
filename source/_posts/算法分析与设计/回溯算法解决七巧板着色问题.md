---
title: 回溯算法解决七巧板着色问题
date: 2019-10-09 16:59:16
summary: 本文基于Java采用四色定理和回溯算法解决七巧板着色问题，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 四色定理

四色定理是一种关于地图着色的定理，指出任何平面地图都可以只用四种颜色进行着色，使得相邻的区域颜色不同。

简单来说，这个定理表明，如果我们把一个地图的各个区域看作是节点，它们之间的边界看作是边，那么任何平面地图都可以被着成四种颜色，而且相邻区域必须使用不同的颜色。

这个定理最初由英国数学家弗朗西斯·贝克（Francis Guthrie）在1852年提出，但直到1976年才由美国数学家肯尼斯·阿普尔（Kenneth Appel）和沃夫冈·哈肯（Wolfgang Haken）通过使用计算机证明了该定理的正确性，这是第一个涉及计算机的数学证明。尽管该定理已被证明，但仍存在一些复杂的地图需要使用四种颜色进行着色，因此该定理并没有提供一个实用的算法来解决着色问题。

# 七巧板

七巧板是一种传统的中国智力玩具，由七个不同形状的木板组成，这些木板可以拼接在一起形成各种形状的图案。这些木板的形状包括正方形、三角形和菱形等。七巧板最早可以追溯到中国宋代（960年-1279年），在中国的传统文化中，七巧板常被用于教育和娱乐。

拼图是将多个小块组合成一个整体的游戏。而七巧板则是将已有的七个小块拼出不同的图案。因为七巧板有多种组合方式和玩法，对人的空间想象能力、逻辑推理能力、手眼协调能力和动手能力等都有很好的锻炼作用。同时，七巧板的制作也需要很高的工艺技能，是一种融合了手工艺和智力开发的艺术品。因此，七巧板被誉为是中国传统文化中的珍品之一。

# 功能需求

请编写一个程序来为七巧板着色，要求如下：
- 使用不超过4种颜色对七巧板进行着色。
- 相邻的带板块（即相邻的七巧板块之间有公共边）必须使用不同的颜色进行着色。
- 可以使用1、2、3、4来表示不同的颜色。
- 最终输出着色方案。

请注意，不同的七巧板可能需要使用不同的着色方案，因此您需要编写一个通用的程序来解决这个问题。您可以使用任何您熟悉的编程语言来实现此需求。

# 程序设计

编程求解过程用到了**回溯法**：
在某个顶点处涂所有颜色都与前面已涂色发生冲突，则进行回溯，返回上一个顶点试探下一种颜色。

注意：数组元素 color[i]=1 即表示对应i顶点的颜色是1

# 编程实现

```java
public class Puzzle {
    
    private static final int BOARD_NUMBER = 7;
    
    //定义七巧板
    private char[] board = new char[BOARD_NUMBER];
    
    private int[][] edge = new int[BOARD_NUMBER][BOARD_NUMBER];

    //初始化所有顶点均涂色0
    private int[] color = new int[BOARD_NUMBER];
    
    public Puzzle(char[] board, int[][] edge) {
        this.board = board;
        this.edge = edge;
    }
    
    public void colour() {
        int vertex = 0;
        while (vertex < BOARD_NUMBER) {
            int flag = 1;
            color[vertex]++;
            if (color[vertex] > 4) {
                color[vertex] = 0;
                vertex--;
                continue;
            }
            for (int adjVertex = 0; adjVertex < vertex; adjVertex++) {
                if (edge[vertex][adjVertex] == 1 && color[vertex] == color[adjVertex]) {
                    flag = 0;
                    break;
                }
            }
            if (flag == 0) {
                continue;
            }
            vertex++;
        }
        for (int i = 0; i < BOARD_NUMBER; i++) {
            System.out.println(board[i] + "涂色为：" + color[i]);
        }
    }
    
    public static void main(String[] args) {
        char[] board = new char[] {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int[][] edge = new int[][] {{0, 1, 0, 0, 1, 1, 0}, {1, 0, 1, 1, 0, 0, 0},
                                    {0, 1, 0, 1, 0, 0, 0}, {0, 1, 1, 0, 1, 0, 1},
                                    {1, 0, 0, 1, 0, 1, 1}, {1, 0, 0, 0, 1, 0, 0},
                                    {0, 0, 0, 1, 1, 0, 0}};
        Puzzle p = new Puzzle(board, edge);
        p.colour();
    }

}
```

这次没有编写单独的测试类，直接在Puzzle类里面写了main方法进行测试。

运行结果：
A涂色为：1
B涂色为：2
C涂色为：1
D涂色为：3
E涂色为：2
F涂色为：3
G涂色为：1

可见，确实4色可解，而且是**3色即可解**（本问题比起地图着色等复杂着色问题还是简单太多了）。

只要我们稍加修饰，就可以把涂色的1、2、3、4替换成具体颜色，那样也许更直接一些。
