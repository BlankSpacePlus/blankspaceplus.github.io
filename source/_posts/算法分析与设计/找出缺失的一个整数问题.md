---
title: 找出缺失的一个整数问题
date: 2020-02-18 19:54:08
summary: 本文分享找出缺失的一个整数问题算法，用Java编程实现。
mathjax: true
tags:
- 算法
- Java
categories:
- 算法分析与设计
---

# 问题描述

对于1-100之间的数，给出一个不重复的、数据总数99的无序序列，设计算法求解缺的一个数值。

本题可以可扩展成从1-N+1之间不重复的N个数组成的序列找出缺的数据。

# 分析

有三种算法思路，下面会有各自的分析，这里就不加以赘述了……

# 思路一：数组计数

开一个数组，长度是num+2。实际上有num+1个元素，由于缺一个所以需要多开一个，但也为了方便，从索引为1处开始存取，所以是num+2。

遍历原数组，当前元素依据下标在新数组中计数，然后最后从1开始再跑一趟统计值为0的位置，输出即可。

Java编程实现：

```java
private static int arrayCount(int[] array, int num) {
    int[] newArray = new int[num+2];
    for (int i = 0; i < num; i++) {
        newArray[array[i]]++;
    }
    for (int i = 1; i < num+2; i++) {
        if (newArray[i] == 0) {
            return i;
        }
    }
    return -1;
}
```

时间复杂度：O(N) —— 两数组各需要跑一趟
空间复杂度：O(N) —— 额外开一个数组的损耗

# 思路二：排序后找步长

先对数组的元素序列进行排序，再统计每一步的步长，若步长差为1则继续，若为2则输出结果。

需要注意的是有一个特判，因为我先取了排序后第一个元素的值，所以从1开始遍历，此时假使缺的正是最小的元素（排序后的最小值是第二小的），就查不出来。
所以先特判最小值是不是1，这样也避免了最后跑完一趟再输出1，比较划算。

Java编程实现：

```java
private static int sortAndFind(int[] array, int num) {
    Arrays.sort(array);
    int prev = array[0];
    if (prev == 2) {
        return 1;
    }
    for (int i = 1; i < num; i++) {
        if (array[i] != ++prev) {
            return i+1;
        }
    }
    return -1;
}
```

时间复杂度：O(NlogN) —— 主要来自排序算法的时间损耗
空间复杂度：O(logN)~O(N) —— 快速排序的消耗，不能忽略

# 思路三：区间和减去数组元素和

是这样的：先遍历一趟数组，求和一下，得知总值；再用等差数列求和公式求区间总和。

用区间总和减去数组元素和就是答案。

比如说：1-5缺1个元素，1+2+3+4+5=15，给出1、2、4、5四个元素，数组求和是12，15-12=3，即为缺的元素。

Java编程实现：

```java
private static int sumAndFind(int[] array, int num) {
    int sum = 0;
    for (int i : array) {
        sum += i;
    }
    return (num+2)*(num+1)/2-sum;
}
```

时间复杂度：O(N) —— 需要遍历一趟数组求和
空间复杂度：O(1) —— 只需要简单的计算，不需要额外数组空间。

# 完整代码（Java语言描述）

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    private static int arrayCount(int[] array, int num) {
        int[] newArray = new int[num+2];
        for (int i = 0; i < num; i++) {
            newArray[array[i]]++;
        }
        for (int i = 1; i < num+2; i++) {
            if (newArray[i] == 0) {
                return i;
            }
        }
        return -1;
    }

    private static int sortAndFind(int[] array, int num) {
        Arrays.sort(array);
        int prev = array[0];
        if (prev == 2) {
            return 1;
        }
        for (int i = 1; i < num; i++) {
            if (array[i] != ++prev) {
                return i+1;
            }
        }
        return -1;
    }

    private static int sumAndFind(int[] array, int num) {
        int sum = 0;
        for (int i : array) {
            sum += i;
        }
        return (num+2)*(num+1)/2-sum;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num = scanner.nextInt();
        int[] array = new int[num];
        for (int i = 0; i < num; i++) {
            array[i] = scanner.nextInt();
        }
        scanner.close();
        System.out.println(arrayCount(array, num));
        System.out.println(sortAndFind(array, num));
        System.out.println(sumAndFind(array, num));
    }

}
```

# 结论
算法三较为高效，事实上，直接求解往往比开花式的技巧高效、简洁。
