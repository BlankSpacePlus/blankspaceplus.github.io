---
title: 加密算法
date: 2023-03-25 16:26:34
summary: 本文分享经典加密算法的基础理论及其实现案例。
tags:
- 信息安全
categories:
- 计算机科学基础
---

# 常见加密算法

- AES算法（Advanced Encryption Standard 高级加密标准）是一种常用的对称加密算法，以密码分组链接方式，依次对明文进行处理，采用了多重代换、多重转换等复杂运算，极大地增加了密码的复杂度。AES算法具有高安全性、运算速度快、适应性强等特点。
- DES算法（Data Encryption Standard 数据加密标准）是一种比较基础的对称加密算法，工作模式为密码块链。DES算法使用56位密钥，将明文按8个字节一组进行加密，通过16轮之后得到密文。但是由于DES的密钥长度过短，已经不再安全。
- MD5算法（Message-Digest Algorithm 5）是一种常用的哈希函数，可以将任意长度的消息摘要成固定长度（128位）的摘要信息。MD5算法具有加密速度快、输出结果长度固定等特点，主要用于数据完整性校验和数字签名等领域。
- RSA算法是一种公钥加密算法，基于数学上的大质数分解问题，广泛用于数字证书、VPN等通信领域。RSA算法的关键在于找到两个足够长且不同质的素数，随机生成一个大数n为这两个素数的积，然后选择一个整数e为公钥，使得e和(n)互质。再计算出另一个整数d，使得e和d模n同余，则d为私钥，可以生成数字签名和解密加密数据。
- SHA-256算法（Secure Hash Algorithm 256）是一种常用的哈希函数，与MD5相似，但输出结果更长（256位）。SHA256算法具有加密强度高、抗攻击能力强、输出结果长度长等特点，被广泛应用于密码学领域和网络安全领域。

# AES算法

AES（Advanced Encryption Standard）是一种对称加密算法，它是目前应用最广泛的加密算法之一，常被用于数据的加密和解密。

AES算法可以采用不同的密钥长度，包括128位、192位和256位。密钥越长，加密强度越高，但也会增加加解密的时间和计算资源的消耗。

AES算法的加密过程是通过一系列的数学运算来实现的。它使用一个密钥来对数据进行加密，然后使用同样的密钥来对加密后的数据进行解密。加密和解密过程中使用的密钥必须是相同的，因此称为对称加密算法。

AES算法中的加密和解密过程都是基于矩阵操作的。数据会被分成一系列的块，并且每个块都会被转换成一个矩阵。这些矩阵会通过一系列的变换来进行加密或解密，包括字节替换、行移位、列混淆和轮密钥加。

AES算法的加密强度很高，因为它使用的是对称加密算法，且在处理每个块时都使用了多个变换和不同的密钥。它已经成为了广泛使用的加密算法，被应用于数据传输、数据存储和加密通信等场景。

## AES算法实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN 1000

const char str16[] = "0123456789abcdef";

int m[250] = {0};

const unsigned int S[16][16] = {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
                                0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
                                0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
                                0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
                                0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
                                0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
                                0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
                                0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
                                0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
                                0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
                                0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
                                0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
                                0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
                                0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
                                0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
                                0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};

const unsigned int SR[16][16] = {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
                                 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
                                 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
                                 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
                                 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
                                 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
                                 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
                                 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
                                 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
                                 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
                                 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
                                 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
                                 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
                                 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
                                 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
                                 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};

const unsigned int Rcon[10] = {0x01000000, 0x02000000,
                               0x04000000, 0x08000000,
                               0x10000000, 0x20000000,
                               0x40000000, 0x80000000,
                               0x1b000000, 0x36000000};

const int colM[4][4] = {2, 3, 1, 1,
                        1, 2, 3, 1,
                        1, 1, 2, 3,
                        3, 1, 1, 2};

const int colMR[4][4] = {14, 11, 13, 9,
                         9, 14, 11, 13,
                         13, 9, 14, 11,
                         11, 13, 9, 14};

unsigned int w[44] = {0};

void substitute(unsigned int *state)
{
    unsigned int tmp;
    for (int i = 0; i < 16; i++)
    {
        tmp = state[i];
        state[i] = S[tmp / 16][tmp % 16];
    }
    return;
}

void substituteR(unsigned int *state)
{
    unsigned int tmp;
    for (int i = 0; i < 16; i++)
    {
        tmp = state[i];
        state[i] = SR[tmp / 16][tmp % 16];
    }
    return;
}

void row_shift(unsigned int *state)
{
    unsigned int tmp[16] = {0};
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            tmp[4 * j + i] = state[(4 * j + 5 * i) % 16];
        }
        for (int j = 0; j < 4; j++)
        {
            state[4 * j + i] = tmp[4 * j + i];
        }
    }
}

void row_shiftR(unsigned int *state)
{
    unsigned int tmp[16] = {0};
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            tmp[4 * j + i] = state[(4 * j - 3 * i + 16) % 16];
        }
        for (int j = 0; j < 4; j++)
        {
            state[4 * j + i] = tmp[4 * j + i];
        }
    }
}

unsigned int multi(unsigned char a, unsigned char b)
{
    unsigned int ans = 0, v;
    for (int i = 0; i < 8; i++)
    {
        if ((b & 0x01) != 0)
        {
            ans ^= a;
        }
        v = a >> 7;
        a = a << 1;
        if (v != 0)
        {
            a ^= 0x1b;
        }
        b = b >> 1;
    }
    return ans;
}

void col_mix(unsigned int *state)
{
    unsigned int tmp, statep[16];
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            tmp = 0;
            for (int k = 0; k < 4; k++)
            {
                tmp ^= multi(colM[i][k], state[k + 4 * j]);
            }
            statep[i + 4 * j] = tmp & 0x00ff;
        }
    }
    for (int i = 0; i < 16; i++)
    {
        state[i] = statep[i];
    }
}

void col_mixR(unsigned int *state)
{
    unsigned int tmp, statep[16];
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            tmp = 0;
            for (int k = 0; k < 4; k++)
            {
                tmp = tmp ^ multi(colMR[i][k], state[k + 4 * j]);
            }
            statep[i + 4 * j] = tmp & 0x00ff;
        }
    }
    for (int i = 0; i < 16; i++)
    {
        state[i] = statep[i];
    }
}

unsigned int T(unsigned int x, int t)
{
    unsigned int tmp = 0;
    int r, c;
    x = (x << 8) | (x >> 24);
    for (int i = 0; i < 4; i++)
    {
        c = x % 16;
        x >>= 4;
        r = x % 16;
        x >>= 4;
        tmp |= S[r][c] << (8 * i);
    }
    tmp ^= Rcon[t];
    return tmp;
}

void generate_w(char *strk)
{
    unsigned int tmp, key[16];
    for (int i = 0; i < 16; i++)
    {
        key[i] = (unsigned int)strk[i];
        w[i / 4] |= key[i] << ((3 - i % 4) * 8);
    }
    for (int i = 4; i < 44; i++)
    {
        if (i % 4 != 0)
        {
            w[i] = w[i - 4] ^ w[i - 1];
        }
        else
        {
            w[i] = w[i - 4] ^ T(w[i - 1], i / 4 - 1);
        }
    }
    return;
}

void add(unsigned int *state, int t)
{
    unsigned int tmp = 0;
    for (int i = 0; i < 16; i++)
    {
        tmp |= state[i] << ((3 - i % 4) * 8);
        if (i % 4 == 3)
        {
            tmp ^= w[4 * t + i / 4];
            for (int j = 0; j < 4; j++)
            {
                state[i - j] = tmp % 256;
                tmp >>= 8;
            }
            tmp = 0;
        }
    }
}

char *int_to_str_en(unsigned int *ct)
{
    static char ans[33];
    ans[32] = '\0';
    unsigned int tmp;
    for (int i = 0; i < 16; i++)
    {
        tmp = ct[i];
        ans[2 * i] = str16[(tmp / 16) % 16];
        ans[2 * i + 1] = str16[tmp % 16];
    }
    return ans;
}

char *int_to_str_de(unsigned int *ct)
{
    static char anst[17];
    anst[16] = '\0';
    unsigned int tmp;
    for (int i = 0; i < 16; i++)
    {
        tmp = ct[i];
        anst[i] = (char)tmp;
    }
    return anst;
}

char *aes_encode(char *strx, char *strk)
{
    if (!(strlen(strx) == 16 && strlen(strk) == 16))
    {
        perror("invalid length");
        return NULL;
    }

    unsigned int bit[16] = {0};
    for (int i = 0; i < 16; i++)
    {
        bit[i] = (unsigned int)strx[i];
    }
    generate_w(strk);
    add(bit, 0);
    for (int t = 1; t < 10; t++)
    {
        substitute(bit);
        row_shift(bit);
        col_mix(bit);
        add(bit, t);
    }
    substitute(bit);
    row_shift(bit);
    add(bit, 10);
    return int_to_str_en(bit);
}

char *aes_decode(char *strx, char *strk)
{
    if (!(strlen(strx) == 32 && strlen(strk) == 16))
    {
        perror("invalid length");
        return NULL;
    }
    m['0'] = 0;
    m['1'] = 1;
    m['2'] = 2;
    m['3'] = 3;
    m['4'] = 4;
    m['5'] = 5;
    m['6'] = 6;
    m['7'] = 7;
    m['8'] = 8;
    m['9'] = 9;
    m['a'] = 10;
    m['b'] = 11;
    m['c'] = 12;
    m['d'] = 13;
    m['e'] = 14;
    m['f'] = 15;
    unsigned int bit[16] = {0};
    for (int i = 0; i < 16; i++)
    {
        bit[i] = m[strx[2 * i]];
        bit[i] = (bit[i] << 4) | m[strx[2 * i + 1]];
    }
    generate_w(strk);
    add(bit, 10);
    for (int t = 9; t > 0; t--)
    {
        row_shiftR(bit);
        substituteR(bit);
        add(bit, t);
        col_mixR(bit);
    }
    row_shiftR(bit);
    substituteR(bit);
    add(bit, 0);
    return int_to_str_de(bit);
}

#if 1
int main(int argc, void *argv[])
{
    char *option, *text, *key, *out;

    if (argc != 4)
    {
        printf("Usage: aes <--encode | --decode> <text> <key>\n");
        return 0;
    }
    else
    {
        option = argv[1];
        text = argv[2];
        key = argv[3];
        if (strcmp(option, "--encode") == 0)
        {
            out = aes_encode(text, key);
            puts(out);
        }
        else if (strcmp(option, "--decode") == 0)
        {
            out = aes_decode(text, key);
            puts(out);
        }
        else
        {
            printf("Usage: aes <--encode | --decode> <text> <key>\n");
            return 0;
        }
    }

    return 0;
}
#endif
```

# DES算法

DES（Data Encryption Standard）算法是一种对称加密算法，也是一种古老的加密算法。它使用一个密钥来对数据进行加密和解密，密钥长度为56位。

DES算法的加密和解密过程都是通过一系列的替换、置换和混淆等操作来实现的。加密过程中，数据会被分成64位的块，然后通过16轮的迭代来进行加密。每轮加密中，数据会经过初始置换、Feistel网络、轮密钥加和逆置换等步骤。其中Feistel网络是DES算法的核心部分，它通过迭代的方式来对数据进行加密和解密。在每轮加密中，会使用不同的子密钥进行处理，子密钥是从主密钥中派生出来的。

DES算法虽然曾经是广泛使用的加密算法，但由于密钥长度过短，加密强度较弱，易受到暴力破解攻击，因此已经逐渐被更安全的加密算法所取代，如AES算法等。为了提高DES算法的安全性，后来又出现了3DES算法，它是通过对数据进行三次DES加密来提高加密强度。

## DES算法实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_LEN 1000

const char str16[] = "0123456789abcdef";
int m[250] = {0};
//置换IP表
const int IP[64] = {
    58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
    62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
    57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
    61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7};
//逆置换IP-1表
const int IPR[64] = {
    40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,
    38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
    36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,
    34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25};
// E位选择表(扩展置换表)
const int E[48] = {
    32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,
    8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
    16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
    24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1};
// P换位表(单纯换位表)
const int P[32] = {
    16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10,
    2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25};
// PC1选位表(密钥生成置换表1)
const int PC1[56] = {
    57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
    10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
    63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
    14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4};
// PC2选位表(密钥生成置换表2)
const int PC2[48] = {
    14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
    23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
    41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
    44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32};
//左移位数表
const int LOOP[16] = {
    1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
// S盒
const int S[8][4][16] = {
    // S1
    14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
    0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
    4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
    15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13,
    // S2
    15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
    3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
    0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
    13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9,
    // S3
    10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
    13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
    13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
    1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12,
    // S4
    7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
    13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
    10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
    3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14,
    // S5
    2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
    14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
    4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
    11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3,
    // S6
    12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
    10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
    9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
    4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13,
    // S7
    4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
    13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
    1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
    6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12,
    // S8
    13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
    1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
    7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
    2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11};

int L[17][32], R[17][32], C[17][28], D[17][28], K[17][48], FT[64];

void padding(char *str, int *rep)
{
    for (int i = 0; i < strlen(str) * 8; i++)
    {
        rep[i] = (str[i / 8] >> (7 - i % 8)) & 0x01;
    }
    return;
}

void ip_permutate(int *X)
{
    for (int i = 0; i < 32; i++)
    {
        L[0][i] = X[IP[i] - 1];
        R[0][i] = X[IP[i + 32] - 1];
    }
    return;
}

void key_generate(int *X)
{
    for (int i = 0; i < 28; i++)
    {
        C[0][i] = X[PC1[i] - 1];
        D[0][i] = X[PC1[i + 28] - 1];
    }
    for (int i = 1; i <= 16; i++)
    {
        for (int j = 0; j < 28; j++)
        {
            C[i][j] = C[i - 1][(j + LOOP[i - 1]) % 28];
            D[i][j] = D[i - 1][(j + LOOP[i - 1]) % 28];
        }
    }
    for (int i = 1; i <= 16; i++)
    {
        for (int j = 0; j < 48; j++)
        {
            if (PC2[j] <= 28)
            {
                K[i][j] = C[i][PC2[j] - 1];
            }
            else
            {
                K[i][j] = D[i][PC2[j] - 29];
            }
        }
    }
    return;
}

void F(int *X, int *Y, int *f)
{
    int e[48], r, c, p[32], res;
    for (int i = 0; i < 48; i++)
    {
        e[i] = X[E[i] - 1];
        e[i] = (e[i] ^ Y[i]) & 0x01;
    }
    for (int i = 0; i < 8; i++)
    {
        r = (e[6 * i] << 1) | e[6 * i + 5];
        c = (e[6 * i + 1] << 3) | (e[6 * i + 2] << 2) | (e[6 * i + 3] << 1) | e[6 * i + 4];
        res = S[i][r][c];
        for (int j = 3; j >= 0; j--)
        {
            p[4 * i + j] = res % 2;
            res /= 2;
        }
    }
    for (int i = 0; i < 32; i++)
    {
        f[i] = p[P[i] - 1];
    }
    return;
}

void calculate_en(int t)
{
    int f[32];
    F(R[t - 1], K[t], f);
    for (int i = 0; i < 32; i++)
    {
        L[t][i] = R[t - 1][i];
        R[t][i] = L[t - 1][i] ^ f[i];
    }
    return;
}

void calculate_de(int t)
{
    int f[32];
    F(R[t - 1], K[17 - t], f);
    for (int i = 0; i < 32; i++)
    {
        L[t][i] = R[t - 1][i];
        R[t][i] = L[t - 1][i] ^ f[i];
    }
    return;
}

void ip_reverse(int *X, int *Y)
{
    for (int i = 0; i < 64; i++)
    {
        if (IPR[i] <= 32)
        {
            FT[i] = X[IPR[i] - 1];
        }
        else
        {
            FT[i] = Y[IPR[i] - 33];
        }
    }
}

char *int_to_str_en(int *ct)
{
    static char ans[17];
    ans[16] = '\0';
    int tmp;
    for (int i = 0; i < 16; i++)
    {
        tmp = 0;
        for (int j = 0; j < 4; j++)
        {
            tmp = 2 * tmp + ct[4 * i + j];
        }
        ans[i] = str16[tmp];
    }
    return ans;
}

char *int_to_str_de(int *ct)
{
    static char anst[9];
    anst[8] = '\0';
    int tmp;
    for (int i = 0; i < 8; i++)
    {
        tmp = 0;
        for (int j = 0; j < 8; j++)
        {
            tmp = 2 * tmp + ct[8 * i + j];
        }
        anst[i] = (char)tmp;
    }
    return anst;
}

char *des_encode(char *strx, char *strk)
{
    if (!(strlen(strx) == 8 && strlen(strk) == 8))
    {
        perror("invalid length");
        return NULL;
    }

    int bit[64] = {0}, key[64] = {0};
    padding(strx, bit);
    padding(strk, key);
    ip_permutate(bit);
    key_generate(key);
    for (int i = 1; i <= 16; i++)
    {
        calculate_en(i);
    }
    ip_reverse(R[16], L[16]);
    return int_to_str_en(FT);
}

char *des_decode(char *strx, char *strk)
{
    if (!(strlen(strx) == 16 && strlen(strk) == 8))
    {
        perror("invalid length");
        return NULL;
    }
    m['0'] = 0;
    m['1'] = 1;
    m['2'] = 2;
    m['3'] = 3;
    m['4'] = 4;
    m['5'] = 5;
    m['6'] = 6;
    m['7'] = 7;
    m['8'] = 8;
    m['9'] = 9;
    m['a'] = 10;
    m['b'] = 11;
    m['c'] = 12;
    m['d'] = 13;
    m['e'] = 14;
    m['f'] = 15;
    int bit[64] = {0}, key[64] = {0}, res;
    for (int i = 0; i < strlen(strx); i++)
    {
        res = m[strx[i]];
        for (int j = 3; j >= 0; j--)
        {
            bit[4 * i + j] = res % 2;
            res /= 2;
        }
    }
    padding(strk, key);
    ip_permutate(bit);
    key_generate(key);
    for (int i = 1; i <= 16; i++)
    {
        calculate_de(i);
    }
    ip_reverse(R[16], L[16]);
    return int_to_str_de(FT);
}

#if 1
int main(int argc, void *argv[])
{
    char *option, *text, *key, *out;
    // 64bit - 8char
    if (argc != 4)
    {
        printf("Usage: des <--encode | --decode> <text> <key>\n");
        return 0;
    }
    else
    {
        option = argv[1];
        text = argv[2];
        key = argv[3];
        if (strcmp(option, "--encode") == 0)
        {
            out = des_encode(text, key);
            puts(out);
        }
        else if (strcmp(option, "--decode") == 0)
        {
            out = des_decode(text, key);
            puts(out);
        }
        else
        {
            printf("Usage: des <--encode | --decode> <text> <key>\n");
            return 0;
        }
    }

    return 0;
}
#endif
```

# MD5算法

MD5是一种广泛使用的加密算法，它将任意长度的消息作为输入，并生成一个128位的哈希值作为输出。MD5的哈希值通常表示为32个十六进制数。

MD5这个名字是“Message-Digest Algorithm 5”的缩写，它由Ron Rivest于1991年创建。MD5采用了一系列数据处理步骤来生成哈希值。

首先，MD5会对输入消息进行填充（padding），使其长度为64的倍数。填充方式是在消息末尾添加一些比特，以使其长度达到64的倍数，同时保留原始消息的内容。填充后的消息被划分成512比特（64字节）的块，每个块再进行一系列运算，最终得到一个哈希值。

具体来说，MD5会将每个512比特的块划分成16个32比特的子块。然后，MD5会执行四轮处理，每轮处理包括以下四个步骤：
1. 置换（Substitution）：MD5会对每个子块进行一系列置换操作，将输入框中的32位二进制数转换为另一组32位数。
2. 排序（Permutation）：MD5会根据一定规则对子块进行排序。
3. 循环移位（Shift）：MD5会对子块进行一定的左移操作。
4. 加（Addition）：MD5会将子块与上一轮处理后的结果相加，生成一个新的结果。

经过四轮处理，最终可以得到一个128比特的哈希值。这个哈希值是唯一的，并且对于不同的输入数据，它也会生成不同的哈希值。因此，MD5可以用于验证数据的完整性，以及密码的安全性等方面。

尽管MD5在密码学中拥有广泛的应用，但它已经被证明存在一些漏洞，使其变得不太安全。在现代密码学中，通常使用更强大的算法，如SHA-256等来代替MD5。

## MD5算法实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define A 0x67452301
#define B 0xefcdab89
#define C 0x98badcfe
#define D 0x10325476
#define MAX_LEN 1000
unsigned int strlength, num, FA, FB, FC, FD;

const char str16[] = "0123456789abcdef";
// 4*16
const unsigned int T[] = {
	0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a,
	0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
	0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340,
	0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
	0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8,
	0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
	0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa,
	0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
	0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92,
	0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
	0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

const unsigned int s[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7,
						  12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9,
						  14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16,
						  23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21,
						  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};

unsigned int F(unsigned int X, unsigned int Y, unsigned int Z)
{
	return (X & Y) | (~X & Z);
}

unsigned int G(unsigned int X, unsigned int Y, unsigned int Z)
{
	return (X & Z) | (Y & ~Z);
}

unsigned int H(unsigned int X, unsigned int Y, unsigned int Z)
{
	return X ^ Y ^ Z;
}

unsigned int I(unsigned int X, unsigned int Y, unsigned int Z)
{
	return Y ^ (X | ~Z);
}

unsigned int *padding(char *str)
{
	unsigned int slen = strlen(str);
	num = (slen * 8 + 64) / 512 + 1;
	strlength = num * 16;
	static unsigned int vec[MAX_LEN] = {0};
	for (unsigned int i = 0; i < slen; i++)
	{
		//小端 256进制
		vec[i >> 2] |= (unsigned int)(str[i]) << ((i % 4) * 8);
	}
	//补充1000..000
	vec[slen >> 2] |= 0x80 << ((slen % 4) * 8);
	unsigned int tmp = slen << 3;
	vec[strlength - 2] = tmp;
	return vec;
}

char *uin_to_str(unsigned int x, unsigned int y, unsigned int z,
				 unsigned int k)
{
	static char ans[33];
	ans[32] = '\0';
	for (int i = 0; i < 4; i++)
	{
		unsigned int tmp = (x >> (8 * i)) % (1 << 8);
		ans[2 * i] = str16[(tmp / 16) % 16];
		ans[2 * i + 1] = str16[tmp % 16];
	}
	for (int i = 4; i < 8; i++)
	{
		unsigned int tmp = (y >> (8 * i)) % (1 << 8);
		ans[2 * i] = str16[(tmp / 16) % 16];
		ans[2 * i + 1] = str16[tmp % 16];
	}
	for (int i = 8; i < 12; i++)
	{
		unsigned int tmp = (z >> (8 * i)) % (1 << 8);
		ans[2 * i] = str16[(tmp / 16) % 16];
		ans[2 * i + 1] = str16[tmp % 16];
	}
	for (int i = 12; i < 16; i++)
	{
		unsigned int tmp = (k >> (8 * i)) % (1 << 8);
		ans[2 * i] = str16[(tmp / 16) % 16];
		ans[2 * i + 1] = str16[tmp % 16];
	}
	return ans;
}

unsigned int rotateL(unsigned int a, unsigned int n)
{
	return (a << n) | (a >> (32 - n));
}

void update(unsigned int *md, int res, int t, int y)
{
	for (int i = 4; i >= 2; i--)
	{
		md[i] = md[i - 1];
	}
	md[1] = md[1] + rotateL(md[0] + res + t + T[y], s[y]);
	md[0] = md[4];
}

void calculate(unsigned int *X)
{
	unsigned int md[5], g, k;
	md[0] = A;
	md[1] = B;
	md[2] = C;
	md[3] = D;
	md[4] = 0;
	for (int i = 0; i < 16; i++)
	{
		g = F(md[1], md[2], md[3]);
		k = i;
		update(md, g, X[k], i);
	}
	for (int i = 16; i < 32; i++)
	{
		g = G(md[1], md[2], md[3]);
		k = (5 * i + 1) % 16;
		update(md, g, X[k], i);
	}
	for (int i = 32; i < 48; i++)
	{
		g = H(md[1], md[2], md[3]);
		k = (3 * i + 5) % 16;
		update(md, g, X[k], i);
	}
	for (int i = 48; i < 64; i++)
	{
		g = I(md[1], md[2], md[3]);
		k = (7 * i) % 16;
		update(md, g, X[k], i);
	}
	FA = A + md[0];
	FB = B + md[1];
	FC = C + md[2];
	FD = D + md[3];
}

char *md5_encode(char *str)
{
	unsigned int *vect;
	vect = padding(str);
	unsigned int tmp[16];
	for (unsigned int i = 0; i < num; i++)
	{
		for (int j = 0; j < 16; j++)
		{
			tmp[j] = vect[16 * i + j];
		}
		calculate(tmp);
	}
	return uin_to_str(FA, FB, FC, FD);
}

#if 1
int main(int argc, void *argv[])
{
	char *option, *text, *out;

	if (argc != 3)
	{
		printf("Usage: md5 <--encode> <text>\n");
		return 0;
	}
	else
	{
		option = argv[1];
		text = argv[2];
		if (strcmp(option, "--encode") == 0)
		{
			out = md5_encode(text);
			puts(out);
		}
		else
		{
			printf("Usage: md5 <--encode> <text>\n");
			return 0;
		}
	}

	return 0;
}
#endif
```

# RSA算法

RSA算法是一种非对称加密算法，是目前最广泛使用的加密算法之一。它的安全性基于质因数分解难题，即将一个大的合数分解为其素数因子的乘积是一个困难的数学问题。

RSA算法中，每个用户都有一对密钥：公钥和私钥。公钥可以公开，用于加密数据，私钥用于解密数据。因此，RSA算法也被称为公钥加密算法。

RSA算法的加密过程如下：首先，将接收者的公钥发送给发送者。发送者使用该公钥对数据进行加密，得到密文，并将密文发送给接收者。接收者使用自己的私钥对密文进行解密，得到原始数据。

RSA算法的安全性主要取决于密钥的长度。通常，密钥长度越长，加密强度越高，但加密和解密的速度也越慢。在实际应用中，一般会采用2048位或更长的密钥来保证安全性。

RSA算法不仅可以用于加密数据，还可以用于数字签名和密钥协商等领域。因此，它被广泛应用于电子商务、金融、电子邮件等领域。

## RSA算法实现

```cpp
#include <gmpxx.h>
#include <iostream>
#include <cstdio>
#include <time.h>
using namespace std;

mpz_t p, q, n, phi, pub_key, pri_key;
string pub_keystr, pri_keystr, nstr, m, c;

void init()
{
    mpz_init(p);
    mpz_init(q);
    mpz_init(n);
    mpz_init(phi);
    mpz_init(pub_key);
    mpz_init(pri_key);
}

void generate_pq()
{
    gmp_randstate_t seed;
    gmp_randinit_default(seed);
    gmp_randseed_ui(seed, time(NULL));
    mpz_urandomb(p, seed, 1024);
    mpz_urandomb(q, seed, 1024);
    mpz_nextprime(p, p);
    mpz_nextprime(q, q);
}

void calculate()
{
    mpz_mul(n, q, p);
    mpz_sub_ui(p, p, 1);
    mpz_sub_ui(q, q, 1);
    mpz_mul(phi, p, q);
}

void generate_key()
{
    mpz_set_ui(pub_key, 65537);
    mpz_invert(pri_key, pub_key, phi);
    mpz_class temp_n(n);
    mpz_class temp_pub(pub_key);
    mpz_class temp_pri(pri_key);
    nstr = temp_n.get_str();
    pub_keystr = temp_pub.get_str();
    pri_keystr = temp_pri.get_str();
}

string rsa_encode(string strm)
{
    mpz_t m, temp_pub, temp_n;
    string ans = "";
    mpz_init(m);
    mpz_init(temp_pub);
    mpz_init(temp_n);
    mpz_set_str(temp_pub, pub_keystr.c_str(), 10);
    mpz_set_str(temp_n, nstr.c_str(), 10);
    for (int i = 0; i < strm.length(); i++)
    {
        mpz_set_ui(m, (unsigned long)strm[i]);
        mpz_powm(m, m, temp_pub, temp_n);
        mpz_class t(m);
        ans += t.get_str();
        ans += '\n';
    }
    mpz_clear(m);
    mpz_clear(temp_pub);
    mpz_clear(temp_n);
    return ans;
}

string rsa_decode(string strc)
{
    mpz_t c, temp_pri, temp_n;
    string ans = "", temp = "";
    mpz_init(c);
    mpz_init(temp_pri);
    mpz_init(temp_n);
    mpz_set_str(temp_pri, pri_keystr.c_str(), 10);
    mpz_set_str(temp_n, nstr.c_str(), 10);
    for (int i = 0; i < strc.length(); i++)
    {
        if (strc[i] == '\n')
        {
            mpz_set_str(c, temp.c_str(), 10);
            mpz_powm(c, c, temp_pri, temp_n);
            mpz_class t(c);
            unsigned long x = t.get_ui();
            ans += (char)x;
            temp = "";
        }
        else
        {
            temp += strc[i];
        }
    }
    return ans;
}

#if 1
int main(int argc, char *argv[])
{
    string option, text, out1, out2;
    if (argc != 3)
    {
        printf("Usage: rsa <--run> <text>\n");
        return 0;
    }
    else
    {
        string option(argv[1]);
        string text(argv[2]);
        if (option == "--run")
        {
            init();
            generate_pq();
            calculate();
            generate_key();
            out1 = rsa_encode(text);
            cout << "Encode: " << out1;
            out2 = rsa_decode(out1);
            cout << "Decode: " << out2 << endl;
        }
        else
        {
            printf("Usage: rsa <--run> <text>\n");
            return 0;
        }
    }

    return 0;
}
#endif
```

# SHA-256算法

SHA-256是一种密码学哈希函数，可以接受任何大小的数据，并输出固定长度为256位的散列值。SHA代表安全哈希算法（Secure Hash Algorithm）。SHA-256是SHA家族算法的最新版本之一，在许多密码学应用程序中广泛使用，包括数字签名、身份验证和消息加密等。

SHA-256是一个单向函数，不能像加密算法那样解密。它将输入文本作为消息，然后通过运算生成一系列唯一的固定字长输出，即散列值。要进行SHA-256哈希，可以使用各种编程语言内置的库或开源实现，例如OpenSSL、Crypto++等。以下是SHA-256哈希的几个重要特点：
- 不可逆性：SHA-256是一个不可逆的算法，因此无法通过散列值反推出原始输入文本。
- 单向性：SHA-256是一个单向函数，只能从输入文本生成散列值，但不能从散列值还原出输入文本。
- 唯一性：不同的输入文本将生成不同的散列值。SHA-256散列值分布范围很广，即使输入文本的微小改变也会产生完全不同的散列值。
- 长度固定：无论输入文本有多长，都将生成长度为256位的散列值。这个长度是确定的，不受输入文本长度的影响。

SHA-256主要优点在于安全性强， 生成摘要时产生的冲突概率小，具有不可逆、单向性和唯一性等特性。因此，SHA-256广泛用于数据完整性校验、数字签名、认证等领域。但是，SHA-256的计算速度相对较慢，因此，在实际应用中需要综合考虑时间效率和安全性。

## SHA-256算法实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_LEN 1000
unsigned int strlength, num;

const char str16[] = "0123456789abcdef";

unsigned int h[] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};

const unsigned int K[] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};

unsigned int rotateR(unsigned int a, unsigned int n)
{
    return (a >> n) | (a << (32 - n));
}

unsigned int Ch(unsigned int X, unsigned int Y, unsigned int Z)
{
    return (X & Y) ^ ((~X) & Z);
}

unsigned int Ma(unsigned int X, unsigned int Y, unsigned int Z)
{
    return (X & Y) ^ (X & Z) ^ (Y & Z);
}

unsigned int sigma0(unsigned int X)
{
    return rotateR(X, 2) ^ rotateR(X, 13) ^ rotateR(X, 22);
}

unsigned int sigma1(unsigned int X)
{
    return rotateR(X, 6) ^ rotateR(X, 11) ^ rotateR(X, 25);
}

unsigned int round0(unsigned int X)
{
    return rotateR(X, 7) ^ rotateR(X, 18) ^ (X >> 3);
}

unsigned int round1(unsigned int X)
{
    return rotateR(X, 17) ^ rotateR(X, 19) ^ (X >> 10);
}

unsigned int *padding(char *str)
{
    unsigned int slen = strlen(str);
    num = (slen * 8 + 64) / 512 + 1;
    strlength = num * 16;
    static unsigned int vec[MAX_LEN] = {0};
    for (unsigned int i = 0; i < slen; i++)
    {
        //大端 256进制
        vec[i >> 2] |= (unsigned int)(str[i]) << ((3 - i % 4) * 8);
    }
    //补充1000..000
    vec[slen >> 2] |= 0x80 << ((3 - slen % 4) * 8);
    vec[strlength - 1] = (slen << 3);
    return vec;
}

void update(unsigned int *ha, unsigned int res0, unsigned int res1)
{
    ha[3] = (ha[3] + res0);
    for (int i = 7; i > 0; i--)
    {
        ha[i] = ha[i - 1];
    }
    ha[0] = res0 + res1;
}

void calculate(unsigned int *w)
{
    unsigned int ha[8], res0, res1, ch, sig1, sig0, ma;
    for (int j = 0; j < 8; j++)
    {
        ha[j] = h[j];
    }
    for (int j = 0; j < 64; j++)
    {
        ch = Ch(ha[4], ha[5], ha[6]);
        sig1 = sigma1(ha[4]);
        ma = Ma(ha[0], ha[1], ha[2]);
        sig0 = sigma0(ha[0]);
        res0 = (ha[7] + sig1 + ch + K[j] + w[j]);
        res1 = (sig0 + ma);
        update(ha, res0, res1);
    }
    for (int j = 0; j < 8; j++)
    {
        h[j] += ha[j];
    }
}

char *uin_to_str(unsigned int *h)
{
    static char ans[65];
    ans[64] = '\0';
    for (int j = 0; j < 8; j++)
    {
        unsigned int x = h[j];
        for (int i = 0; i < 4; i++)
        {
            unsigned int tmp = (x >> (8 * i)) % (1 << 8);
            ans[8 * j + 2 * i] = str16[(tmp / 16) % 16];
            ans[8 * j + 2 * i + 1] = str16[tmp % 16];
        }
    }
    return ans;
}

char *sha256_encode(char *str)
{
    unsigned int *vect = padding(str);
    unsigned int w[64];
    for (int i = 0; i < num; i++)
    {
        for (int j = 0; j < 64; j++)
        {
            if (j < 16)
                w[j] = vect[16 * i + j];
            else
                w[j] = round1(w[j - 2]) + w[j - 7] + round0(w[j - 15]) + w[j - 16];
        }
        calculate(w);
    }
    return uin_to_str(h);
}

#if 1
int main(int argc, void *argv[])
{
    char *option, *text, *out;

    if (argc != 3)
    {
        printf("Usage: sha256 <--encode> <text>\n");
        return 0;
    }
    else
    {
        option = argv[1];
        text = argv[2];
        if (strcmp(option, "--encode") == 0)
        {
            out = sha256_encode(text);
            puts(out);
        }
        else
        {
            printf("Usage: sha256 <--encode> <text>\n");
            return 0;
        }
    }

    return 0;
}
#endif
```
