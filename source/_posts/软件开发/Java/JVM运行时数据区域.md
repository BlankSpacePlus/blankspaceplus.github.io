---
title: JVM运行时数据区域
date: 2023-05-08 22:01:25
summary: 本文分享JVM运行时数据区域的相关内容。
tags:
- Java
- JVM
categories:
- Java
---

# JVM运行时数据区域

Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域在Java虚拟机启动时创建，仅在Java虚拟机终止时销毁。其他数据区域是每个线程的。每个线程的数据区域在线程创建时创建，在线程终止时销毁。

JVM运行时数据区域包括：
- 方法区（Method Area）：存储类的加载信息、常量、静态变量等数据。
- 堆（Heap）：存储对象实例及数组。
- 虚拟机栈（VM Stack）：存储线程执行方法的状态，包括局部变量、操作数栈、方法出口等。
- 本地方法栈（Native Method Stack）：为执行Native方法（即用其他语言编写的方法）提供支持，可以是固定大小的栈，也可以动态扩展。
- 程序计数器寄存器（Program Counter Register）：记录当前线程执行的字节码指令地址。
- 运行时常量池（Run-Time Constant Pool）：存储编译时生成的各种字面量和符号引用，包括类、方法、字段等信息。

其中，方法区、堆、虚拟机栈是线程共享的内存区域，而本地方法栈、程序计数器、运行时常量池是线程私有的内存区域。

## PC寄存器

Java虚拟机可以同时支持多个执行线程。每个Java虚拟机线程都有自己的PC（程序计数器）寄存器。在任何时刻，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法。如果该方法不是本地方法，则PC寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前执行的方法是本地方法，则Java虚拟机的PC寄存器的值未定义。Java虚拟机的PC寄存器足够宽，可以保存特定平台上的returnAddress或本地指针。

## Java虚拟机堆栈

每个Java虚拟机线程都有一个私有的Java虚拟机堆栈，与线程同时创建。Java虚拟机堆栈存储帧。Java虚拟机堆栈类似于传统语言（如C）的堆栈：它保存局部变量和部分结果，并在方法调用和返回中起作用。由于Java虚拟机堆栈除了推入和弹出帧之外从未直接操作过，因此帧可以被堆分配。Java虚拟机堆栈的内存不需要连续。

在《Java®虚拟机规范》第一版中，Java虚拟机堆栈称为Java堆栈。

该规范允许Java虚拟机堆栈的大小为固定大小或根据计算需要动态扩展和收缩。如果Java虚拟机堆栈是固定大小的，则可以在创建该堆栈时独立选择每个Java虚拟机堆栈的大小。

Java虚拟机实现可以为程序员或用户提供控制Java虚拟机堆栈的初始大小以及动态扩展或收缩Java虚拟机堆栈的最大和最小大小。

以下异常条件与Java虚拟机堆栈相关：
- 如果线程中的计算需要比允许的更大的Java虚拟机堆栈，则Java虚拟机将抛出java.lang.StackOverflowError。
- 如果Java虚拟机堆栈可以动态扩展，并且尝试扩展但无法提供足够的内存以实现扩展，或者无法提供足够的内存以创建新线程的初始Java虚拟机堆栈，则Java虚拟机将抛出java.lang.OutOfMemoryError。

## 堆

Java虚拟机具有一个堆，它在所有Java虚拟机线程之间共享。堆是运行时数据区域，用于分配所有类实例和数组的内存。

堆在虚拟机启动时创建。对象的堆存储由自动存储管理系统（称为垃圾回收器）回收；对象不会被显式地释放。 Java虚拟机不假定特定类型的自动存储管理系统，存储管理技术可以根据实现者的系统要求选择。堆可以是固定大小的，也可以根据计算需要扩展，如果不再需要更大的堆，则可以收缩。堆的内存不需要是连续的。

Java虚拟机实现可以为程序员或用户提供控制堆的初始大小，以及如果堆可以动态扩展或收缩，则控制最大和最小堆大小。

以下异常条件与堆有关：
- 如果计算需要的堆比自动存储管理系统提供的堆空间更多，则Java虚拟机会抛出java.lang.OutOfMemoryError。

## 方法区

Java虚拟机有一个方法区，该区域在所有Java虚拟机线程之间共享。方法区类似于传统语言的编译代码存储区或操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池，字段和方法数据以及方法和构造函数的代码，包括在类和接口初始化中使用的特殊方法和实例初始化中使用的方法。

方法区在虚拟机启动时创建。虽然方法区在逻辑上是堆的一部分，但简单的实现可以选择不进行垃圾收集或压缩。本规范不规定方法区的位置或用于管理编译代码的策略。方法区可以是固定大小的，也可以根据计算要求进行扩展，如果不再需要较大的方法区，则可以进行缩小。方法区的内存不需要连续。

Java虚拟机实现可以为程序员或用户提供控制方法区初始大小的控制，以及在方法区大小可变的情况下，控制方法区最大和最小大小的控制。

以下异常条件与方法区相关：
- 如果无法提供方法区内存以满足分配请求，则Java虚拟机会抛出java.lang.OutOfMemoryError异常。

## 运行时常量池

运行时常量池是class文件中constant_pool表的每个类或每个接口的运行时表示。它包含多种常量，从编译时已知的数字字面量到必须在运行时解析的方法和字段引用。运行时常量池的作用类似于传统编程语言的符号表，尽管它包含比典型符号表更广泛的数据。

每个运行时常量池都是从Java虚拟机的方法区分配的。当Java虚拟机创建类或接口时，将构造该类或接口的运行时常量池。

以下异常条件与为类或接口构建运行时常量池相关：
- 当创建类或接口时，如果在Java虚拟机的方法区中分配运行时常量池所需的内存大于可用内存，则Java虚拟机将抛出java.lang.OutOfMemoryError异常。

## 本地方法栈

Java虚拟机的实现可以使用传统的栈（俗称"C栈"）来支持本地方法（即使用Java编程语言之外的语言编写的方法）。本地方法栈也可以被用于Java虚拟机指令集的解释器在诸如C之类的语言中的实现。不能加载本地方法且不依赖于传统栈的Java虚拟机实现不需要提供本地方法栈。如果提供了本地方法栈，则通常在创建每个线程时为每个线程分配一个本地方法栈。

本规范允许本地方法栈的大小可以是固定的，也可以根据计算需要动态扩展和收缩。如果本地方法栈的大小是固定的，则在创建该栈时可以独立选择每个本地方法栈的大小。

Java虚拟机的实现可以提供程序员或用户控制本地方法栈的初始大小，以及在变化大小的本地方法栈的情况下，控制最大和最小方法栈大小。

以下异常情况与本地方法栈相关：
- 如果线程中的计算需要比允许的本地方法栈更大的本地方法栈，则Java虚拟机会抛出java.lang.StackOverflowError。
- 如果本地方法栈可以动态扩展，但尝试进行本地方法栈扩展时无法提供足够的内存，或者无法提供足够的内存来为新线程创建初始本地方法栈，则Java虚拟机会抛出java.lang.OutOfMemoryError。
