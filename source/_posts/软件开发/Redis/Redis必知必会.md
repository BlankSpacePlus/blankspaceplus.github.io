---
title: Redis必知必会
date: 2023-07-28 21:30:00
summary: 本文分享一些Redis有效经验。
tags:
- Redis
- 数据库系统
categories:
- 开发技术
---

# Redis的内存控制方法

降低Redis内存使用最直接的方式就是缩减key和value的长度。
- key长度：在设计key时，在完整描述业务情况下，key值越短越好。
- value长度：value对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。
    - 应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。
    - 在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。工具效率对比：`protostuff-graph > kryo-serializer > hessian > jackson > xml/JAXB > java-build-in-serializer > jboss-serialization`

# Redis的redisObject结构体

Redis存储的所有值对象在内部定义为redisObject结构体：
- type：记录当前对象使用的数据类型 -> string、hash、list、set、zset
- encoding：记录Redis内部编码类型
    - string
        - raw
        - int
        - embstr
    - hash
        - hashtable
        - ziplist
    - list
        - linkedlist
        - ziplist
    - set
        - hashtable
        - intset
    - zset
        - skiplist
        - ziplist
- lru：记录对象最后一次被访问的时间
- int refcount：记录当前对象被引用的次数
- void *ptr：与对象的数据内容相关，如果是整数直接存储数据，否则表示指向数据的指针

# Redis的共享整数对象池

Redis内存维护一个\[0-9999\]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。使用共享对象池后，相同的数据内存使用降低30%以上。

# Redis的SDS

Redis没有采用原生C语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串(simple dynamic string)，简称SDS。
- SDS结构
    - int len：已用字节长度
    - int free：未用字节长度
    - char buf[]：字节数组
- 特点:
    - O(1)时间复杂度获取：字符串长度，已用长度，未用长度。
    - 可用于保存字节数组，支持安全的二进制数据存储。
    - 内部实现空间预分配机制，降低内存再分配次数。
    - 惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。
- 因为字符串(SDS)存在预分配机制，日常开发中要小心预分配带来的内存浪费。<br>字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。字符串预分配每次并不都是翻倍扩容，空间预分配规则如下:
    - 第一次创建len属性等于数据实际大小，free等于0，不做预分配。
    - 修改后如果已有free空间不够且数据小于1M，每次预分配一倍容量。如原有len=60byte，free=0，再追加60byte，预分配120byte，总占用空间:60byte+60byte+120byte+1byte。
    - 修改后如果已有free空间不够且数据大于1MB，每次预分配1MB数据。如原有len=30MB，free=0，当再追加100byte ,预分配1MB，总占用空间:1MB+100byte+1MB+1byte。<br>开发提示:尽量减少字符串频繁修改操作如append，setrange, 改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。
- 字符串重构：指不一定把每份数据作为字符串整体存储，像JSON这样的数据可以使用hash结构，使用二级结构存储也能帮我们节省内存。同时可以使用hmget、hmset命令支持字段的部分读取修改，而不用每次整体存取。

# Redis的编码优化策略

- Redis对外提供了string、list、hash、set、zset等类型，但是Redis内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现，编码不同将直接影响数据的内存占用和读写效率。
- Redis针对每种数据类型(type)可以采用至少两种编码方式来实现，以便通过不同编码实现效率和空间的平衡。
- Redis编码类型转换在Redis写入数据时自动完成，这个转换过程是不可逆的，转换规则只能从小内存编码向大内存编码转换。<br>Redis之所以不支持编码回退，主要是数据增删频繁时，数据向压缩编码转换非常消耗CPU，得不偿失。
- ziplist编码主要目的是为了节约内存，因此所有数据都是采用线性连续的内存结构。ziplist编码是应用范围最广的一种，可以分别作为hash、list、zset类型的底层数据结构实现。
    - ziplist结构：
        - zlbytes：记录整个压缩列表所占字节长度，方便重新调整ziplist空间。类型是int-32，长度为4字节。
        - zltail：记录距离尾节点的偏移量，方便尾节点弹出操作。类型是int-32，长度为4字节。
        - zllen：记录压缩链表节点数量，当长度超过216-2时需要遍历整个列表获取长度，一般很少见。类型是int-16，长度为2字节。
        - entry：记录具体的节点，长度根据实际存储的数据而定。
            - preventrybytes_length：记录前一个节点所占空间，用于快速定位上一个节点，可实现列表反向迭代。
            - encoding：标示当前节点编码和长度，前两位表示编码类型：字符串/整数，其余位表示数据长度。
            - contents：保存节点的值，针对实际数据长度做内存占用优化。
        - zlend：记录列表结尾，占用一个字节。
    - ziplist数据结构特点：
        - 内部表现为数据紧凑排列的一块连续内存数组。
        - 可以模拟双向链表结构，以O(1)时间复杂度入队和出队。
        - 新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。
        - 读写操作涉及复杂的指针移动，最坏时间复杂度为O(n2)。
        - 适合存储小对象和长度有限的数据。
    - ziplist注意事项：
        - 使用ziplist可以分别作为hash、list、zset数据类型实现。
        - 使用ziplist编码类型可以大幅降低内存占用。
        - ziplist实现的数据类型相比原生结构，命令操作更加耗时，不同类型耗时排序：`list < hash < zset`。
        - 针对性能要求较高的场景使用ziplist，建议长度不要超过1000，每个元素大小控制在512字节以内。
        - 命令平均耗时使用`info Commandstats`命令获取，包含每个命令调用次数、总耗时、平均耗时、单位微秒。
- intset编码是集合(set)类型编码的一种，内部表现为存储有序、不重复的整数集，当集合只包含整数且长度不超过set-max-intset-entries配置时被启用。
    - intset结构：
        - encoding：整数表示类型，根据集合内最长整数值确定类型，整数类型划分三种，int-16、int-32、int-64。
        - length：表示集合元素个数。
        - contents：整数数组，按从小到大顺序保存。
    - intset注意事项：
        - intset保存的整数类型根据长度划分，当保存的整数超出当前类型时，将会触发自动升级操作且升级后不再做回退。升级操作将会导致重新申请内存空间，把原有数据按转换类型后拷贝到新数组。
        - 使用intset编码的集合时，尽量保持整数范围一致，如都在int-16范围内。防止个别大整数触发集合升级操作，产生内存浪费。
        - intset数据结构插入命令复杂度为O(n)，查询命令为O(log(n))，由于整数占用空间非常小，所以在集合长度可控的基础上，写入命令执行速度也会非常快，因此当使用整数集合时尽量使用intset编码。

# Redis的key的数量控制策略

- 当使用Redis存储大量数据时，通常会存在大量key，过多的key同样会消耗大量内存。Redis本质是一个数据结构服务器，它为我们提供多种数据结构，如hash、list、set、zset 等结构。使用Redis时不要进入一个误区，大量使用get/set这样的API，把Redis当成Memcached使用。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存。
- 一些结论：
    - 同样的数据使用ziplist编码的hash类型存储比string类型节约内存。
    - 节省内存量随着value空间的减少，越来越明显。
    - hash-ziplist类型比string类型写入耗时，但随着value空间的减少，耗时逐渐降低。 使用hash重构后节省内存量效果非常明显，特变对于存储小对象的场景，内存只有不到原来的1/5。下面分析这种内存优化技巧的关键点：
        - hash类型节省内存的原理是使用ziplist编码，如果使用hashtable编码方式反而会增加内存消耗。
        - ziplist长度需要控制在1000以内，否则由于存取操作时间复杂度在O(n)到O(n2)之间，长列表会导致CPU消耗严重，得不偿失。
        - ziplist适合存储的小对象，对于大对象不但内存优化效果不明显还会增加命令操作耗时。
        - 需要预估键的规模，从而确定每个hash结构需要存储的元素数量。
        - 根据hash长度和元素大小，调整hash-max-ziplist-entries和hash-max-ziplist-value参数，确保hash类型使用ziplist编码。
- 关于hash键和field键的设计：
    - 当键离散度较高时，可以按字符串位截取，把后三位作为哈希的field，之前部分作为哈希的键。如：key=1948480 哈希key=group:hash:1948，哈希field=480。
    - 当键离散度较低时，可以使用哈希算法打散键，如:使用crc32(key)&10000函数把所有的键映射到“0-9999”整数范围内，哈希field存储键的原始值。
    - 尽量减少hash键和field的长度，如使用部分键内容。
- 使用hash结构控制键的规模虽然可以大幅降低内存，但同样会带来问题，需要提前做好规避处理：
    - 客户端需要预估键的规模并设计hash分组规则，加重客户端开发成本。
    - hash重构后所有的键无法再使用超时(expire)和LRU淘汰机制自动删除，需要手动维护删除。
    - 对于大对象，如1KB以上的对象。使用hash-ziplist结构控制键数量。不过瑕不掩瑜，对于大量小对象的存储场景，非常适合使用ziplist编码的hash类型控制键的规模来降低内存。

# Redis缓存问题

- 缓存穿透：查询数据，Redis中没有，缓存未命中，向持久数据库查询发现也不存在，查询失败。当多次缓存未命中时，都去请求持久层数据库造成压力，若用此进行攻击可能压垮数据库。解决方案：
    - 布隆过滤器：布隆过滤器是一种数据结构，对所有可能查询的参数以Hash形式存储，先在控制层进行校验，不符合则丢弃，从而避免对持久层的查询压力。
    - 缓存空对象：缓存未命中后，把返回的空对象写入缓存同时设置一个过期时间，之后再访问时就能直接从缓存读取，保护持久层，但会耗费内存资源。
- 缓存击穿：缓存中可以查询到这个Key，高并发的持续查询这个Key时，穿透了缓存直接请求到持久层数据库，瞬间压力而崩溃。比如热点数据过期的瞬间，请求数据库回写缓存时，短时间内的大量请求瞬间压垮数据库。解决方案：
    - 设置热点数据永不过期：没有过期时间便不会出现上述问题，但会占据内存。
    - 加互斥锁：使用分布式锁，保证每个key同时只有一个线程去查询持久层数据库，其余线程没有分布式锁权限只能等待（即把击穿后的请求加锁等待）从而避免数据库压力，但对分布式锁有一定考验。
- 缓存雪崩：某段时间内，缓存集中过期失效、Redis宕机、服务器重启、断电断网等缓存不可用的情况，所有请求直接打到后端数据库上，然后GG。解决方案：
    - Redis高可用：提高Redis高可用性，使用主从复制、集群等机制保证一台Redis挂掉，其余几台仍可继续正常工作。
    - 限流降级：在缓存失效后，通过加锁或队列来控制线程数量，比如每个Key只允许一个线程读写，其余等待。
    - 数据预热：在正式部署前，把可能访问的数据线预先访问一遍，把部分可能大量访问的数据加载到缓存中，设置不同过期时间，让缓存失效时间点均匀分散。避免用户请求的时候再去加载相关的数据。
